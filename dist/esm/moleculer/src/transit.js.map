{"version":3,"file":"transit.js","sources":["../../../../src/moleculer/src/transit.js"],"sourcesContent":["/*\n * moleculer\n * Copyright (c) 2020 MoleculerJS (https://github.com/moleculerjs/moleculer)\n * MIT Licensed\n */\n\n\"use strict\";\n\nconst P \t\t\t\t= require(\"./packets\");\nconst { Packet } \t\t= require(\"./packets\");\nconst E \t\t\t\t= require(\"./errors\");\n\nconst { Transform } \t= require(\"stream\");\nconst { METRIC }\t\t= require(\"./metrics\");\n\n/**\n * Transit class\n *\n * @class Transit\n */\nclass Transit {\n\n\t/**\n\t * Create an instance of Transit.\n\t *\n\t * @param {ServiceBroker} Broker instance\n\t * @param {Transporter} Transporter instance\n\t * @param {Object?} opts\n\t *\n\t * @memberof Transit\n\t */\n\tconstructor(broker, transporter, opts) {\n\t\tthis.broker = broker;\n\t\tthis.Promise = broker.Promise;\n\t\tthis.logger = broker.getLogger(\"transit\");\n\t\tthis.nodeID = broker.nodeID;\n\t\tthis.metrics = broker.metrics;\n\t\tthis.instanceID = broker.instanceID;\n\t\tthis.tx = transporter;\n\t\tthis.opts = opts;\n\t\tthis.discoverer = broker.registry.discoverer;\n\n\t\tthis.pendingRequests = new Map();\n\t\tthis.pendingReqStreams = new Map();\n\t\tthis.pendingResStreams = new Map();\n\n\t\t/* deprecated */\n\t\tthis.stat = {\n\t\t\tpackets: {\n\t\t\t\tsent: {\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tbytes: 0\n\t\t\t\t},\n\t\t\t\treceived: {\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tbytes: 0\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.connected = false;\n\t\tthis.disconnecting = false;\n\t\tthis.isReady = false;\n\n\t\tconst wrappedMessageHandler = (cmd, packet) => this.messageHandler(cmd, packet);\n\n\t\tthis.publish = this.broker.wrapMethod(\"transitPublish\", this.publish, this);\n\t\tthis.messageHandler = this.broker.wrapMethod(\"transitMessageHandler\", this.messageHandler, this);\n\n\n\t\tif (this.tx) {\n\t\t\tthis.tx.init(this, wrappedMessageHandler, this.afterConnect.bind(this));\n\n\t\t\tthis.tx.send = this.broker.wrapMethod(\"transporterSend\", this.tx.send, this.tx);\n\t\t\tthis.tx.receive = this.broker.wrapMethod(\"transporterReceive\", this.tx.receive, this.tx, { reverse: true });\n\t\t}\n\n\t\tthis.__connectResolve = null;\n\n\t\tthis.registerMoleculerMetrics();\n\t}\n\n\t/**\n\t * Register Moleculer Transit Core metrics.\n\t */\n\tregisterMoleculerMetrics() {\n\t\tif (!this.broker.isMetricsEnabled()) return;\n\n\t\tthis.metrics.register({ name: METRIC.MOLECULER_TRANSIT_READY, type: METRIC.TYPE_GAUGE, description: \"Transit is ready\" }).set(0);\n\t\tthis.metrics.register({ name: METRIC.MOLECULER_TRANSIT_CONNECTED, type: METRIC.TYPE_GAUGE, description: \"Transit is connected\" }).set(0);\n\n\t\tthis.metrics.register({ name: METRIC.MOLECULER_TRANSIT_PONG_TIME, type: METRIC.TYPE_GAUGE, labelNames: [\"targetNodeID\"], description: \"Ping time\" });\n\t\tthis.metrics.register({ name: METRIC.MOLECULER_TRANSIT_PONG_SYSTIME_DIFF, type: METRIC.TYPE_GAUGE, labelNames: [\"targetNodeID\"], description: \"System time difference between nodes\" });\n\n\t\tthis.metrics.register({ name: METRIC.MOLECULER_TRANSIT_ORPHAN_RESPONSE_TOTAL, type: METRIC.TYPE_COUNTER, description: \"Number of orphan responses\" });\n\t}\n\n\t/**\n\t * It will be called after transporter connected or reconnected.\n\t *\n\t * @param {any} wasReconnect\n\t * @returns {Promise}\n\t *\n\t * @memberof Transit\n\t */\n\tafterConnect(wasReconnect) {\n\t\treturn this.Promise.resolve()\n\n\t\t\t.then(() => {\n\t\t\t\tif (wasReconnect) {\n\t\t\t\t\t// After reconnecting, we should send a broadcast INFO packet because there may new nodes.\n\t\t\t\t\t// In case of disabled balancer, it triggers the `makeBalancedSubscriptions` method.\n\t\t\t\t\treturn this.discoverer.sendLocalNodeInfo();\n\t\t\t\t} else {\n\t\t\t\t\t// After connecting we should subscribe to topics\n\t\t\t\t\treturn this.makeSubscriptions();\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t.then(() => this.discoverer.discoverAllNodes())\n\t\t\t.delay(500) // Waiting for incoming INFO packets\n\n\t\t\t.then(() => {\n\t\t\t\tthis.connected = true;\n\t\t\t\tthis.metrics.set(METRIC.MOLECULER_TRANSIT_CONNECTED, 1);\n\n\t\t\t\tthis.broker.broadcastLocal(\"$transporter.connected\", { wasReconnect: !!wasReconnect });\n\n\t\t\t\tif (this.__connectResolve) {\n\t\t\t\t\tthis.__connectResolve();\n\t\t\t\t\tthis.__connectResolve = null;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t});\n\t}\n\n\t/**\n\t * Connect with transporter. If failed, try again after 5 sec.\n\t *\n\t * @memberof Transit\n\t */\n\tconnect() {\n\t\tthis.logger.info(\"Connecting to the transporter...\");\n\t\treturn new this.Promise(resolve => {\n\t\t\tthis.__connectResolve = resolve;\n\n\t\t\tconst doConnect = () => {\n\t\t\t\tlet reconnectStarted = false;\n\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tconst errorHandler = (err) => {\n\t\t\t\t\tif (this.disconnecting) return;\n\t\t\t\t\tif (reconnectStarted) return;\n\n\t\t\t\t\tthis.logger.warn(\"Connection is failed.\", err && err.message || \"Unknown error\");\n\t\t\t\t\tthis.logger.debug(err);\n\n\t\t\t\t\tif (this.opts.disableReconnect) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\treconnectStarted = true;\n\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tthis.logger.info(\"Reconnecting...\");\n\t\t\t\t\t\tdoConnect();\n\t\t\t\t\t}, 5 * 1000);\n\t\t\t\t};\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tthis.tx.connect(errorHandler).catch(errorHandler);\n\t\t\t};\n\n\t\t\tdoConnect();\n\n\t\t});\n\t}\n\n\t/**\n\t * Disconnect with transporter\n\t *\n\t * @memberof Transit\n\t */\n\tdisconnect() {\n\t\tthis.connected = false;\n\t\tthis.isReady = false;\n\t\tthis.disconnecting = true;\n\t\tthis.metrics.set(METRIC.MOLECULER_TRANSIT_CONNECTED, 0);\n\n\t\tthis.broker.broadcastLocal(\"$transporter.disconnected\", { graceFul: true });\n\n\t\treturn this.Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\tif (this.tx.connected) {\n\t\t\t\t\treturn this.discoverer.localNodeDisconnected()\n\t\t\t\t\t\t.then(() => this.tx.disconnect());\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() => this.disconnecting = false);\n\t}\n\n\t/**\n\t * Local broker is ready (all services loaded).\n\t * Send INFO packet to all other nodes\n\t */\n\tready() {\n\t\tif (this.connected) {\n\t\t\tthis.isReady = true;\n\t\t\tthis.metrics.set(METRIC.MOLECULER_TRANSIT_READY, 1);\n\t\t\treturn this.discoverer.localNodeReady();\n\t\t}\n\t}\n\n\t/**\n\t * Send DISCONNECT to remote nodes\n\t *\n\t * @returns {Promise}\n\t *\n\t * @memberof Transit\n\t */\n\tsendDisconnectPacket() {\n\t\treturn this.publish(new Packet(P.PACKET_DISCONNECT)).catch(/* istanbul ignore next */ err => this.logger.debug(\"Unable to send DISCONNECT packet.\", err));\n\t}\n\n\t/**\n\t * Subscribe to topics for transportation\n\t *\n\t * @memberof Transit\n\t */\n\tmakeSubscriptions() {\n\t\tthis.subscribing = this.tx.makeSubscriptions([\n\n\t\t\t// Subscribe to broadcast events\n\t\t\t{ cmd: P.PACKET_EVENT, nodeID: this.nodeID },\n\n\t\t\t// Subscribe to requests\n\t\t\t{ cmd: P.PACKET_REQUEST, nodeID: this.nodeID },\n\n\t\t\t// Subscribe to node responses of requests\n\t\t\t{ cmd: P.PACKET_RESPONSE, nodeID: this.nodeID },\n\n\t\t\t// Discover handler\n\t\t\t{ cmd: P.PACKET_DISCOVER },\n\t\t\t{ cmd: P.PACKET_DISCOVER, nodeID: this.nodeID },\n\n\t\t\t// NodeInfo handler\n\t\t\t{ cmd: P.PACKET_INFO }, // Broadcasted INFO. If a new node connected\n\t\t\t{ cmd: P.PACKET_INFO, nodeID: this.nodeID }, // Response INFO to DISCOVER packet\n\n\t\t\t// Disconnect handler\n\t\t\t{ cmd: P.PACKET_DISCONNECT },\n\n\t\t\t// Heartbeat handler\n\t\t\t{ cmd: P.PACKET_HEARTBEAT },\n\n\t\t\t// Ping handler\n\t\t\t{ cmd: P.PACKET_PING }, // Broadcasted\n\t\t\t{ cmd: P.PACKET_PING, nodeID: this.nodeID }, // Targeted\n\n\t\t\t// Pong handler\n\t\t\t{ cmd: P.PACKET_PONG, nodeID: this.nodeID }\n\n\t\t]).then(() => {\n\t\t\tthis.subscribing = null;\n\t\t});\n\n\t\treturn this.subscribing;\n\t}\n\n\t/**\n\t * Message handler for incoming packets\n\t *\n\t * @param {Array} topic\n\t * @param {String} msg\n\t * @returns {Boolean} If packet is processed return with `true`\n\t *\n\t * @memberof Transit\n\t */\n\tmessageHandler(cmd, packet) {\n\t\ttry {\n\t\t\tconst payload = packet.payload;\n\n\t\t\t// Check payload\n\t\t\tif (!payload) {\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tthrow new E.MoleculerServerError(\"Missing response payload.\", 500, \"MISSING_PAYLOAD\");\n\t\t\t}\n\n\t\t\t// Check protocol version\n\t\t\tif (payload.ver !== this.broker.PROTOCOL_VERSION && !this.opts.disableVersionCheck) {\n\t\t\t\tthrow new E.ProtocolVersionMismatchError({\n\t\t\t\t\tnodeID: payload.sender,\n\t\t\t\t\tactual: this.broker.PROTOCOL_VERSION,\n\t\t\t\t\treceived: payload.ver\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (payload.sender === this.nodeID) {\n\n\t\t\t\t// Detect nodeID conflict\n\t\t\t\tif (cmd === P.PACKET_INFO && payload.instanceID !== this.instanceID) {\n\t\t\t\t\treturn this.broker.fatal(\"ServiceBroker has detected a nodeID conflict, use unique nodeIDs. ServiceBroker stopped.\");\n\t\t\t\t}\n\n\t\t\t\t// Skip own packets (if only built-in balancer disabled)\n\t\t\t\tif (cmd !== P.PACKET_EVENT && cmd !== P.PACKET_REQUEST && cmd !== P.PACKET_RESPONSE)\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Request\n\t\t\tif (cmd === P.PACKET_REQUEST) {\n\t\t\t\treturn this.requestHandler(payload);\n\t\t\t}\n\n\t\t\t// Response\n\t\t\telse if (cmd === P.PACKET_RESPONSE) {\n\t\t\t\tthis.responseHandler(payload);\n\t\t\t}\n\n\t\t\t// Event\n\t\t\telse if (cmd === P.PACKET_EVENT) {\n\t\t\t\tthis.eventHandler(payload);\n\t\t\t}\n\n\t\t\t// Discover\n\t\t\telse if (cmd === P.PACKET_DISCOVER) {\n\t\t\t\tthis.discoverer.sendLocalNodeInfo(payload.sender);\n\t\t\t}\n\n\t\t\t// Node info\n\t\t\telse if (cmd === P.PACKET_INFO) {\n\t\t\t\tthis.discoverer.processRemoteNodeInfo(payload.sender, payload);\n\t\t\t}\n\n\t\t\t// Disconnect\n\t\t\telse if (cmd === P.PACKET_DISCONNECT) {\n\t\t\t\tthis.discoverer.remoteNodeDisconnected(payload.sender, false);\n\t\t\t}\n\n\t\t\t// Heartbeat\n\t\t\telse if (cmd === P.PACKET_HEARTBEAT) {\n\t\t\t\tthis.discoverer.heartbeatReceived(payload.sender, payload);\n\t\t\t}\n\n\t\t\t// Ping\n\t\t\telse if (cmd === P.PACKET_PING) {\n\t\t\t\tthis.sendPong(payload);\n\t\t\t}\n\n\t\t\t// Pong\n\t\t\telse if (cmd === P.PACKET_PONG) {\n\t\t\t\tthis.processPong(payload);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (err) {\n\t\t\tthis.logger.error(err, cmd, packet);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Handle incoming event\n\t *\n\t * @param {any} payload\n\t * @memberof Transit\n\t */\n\teventHandler(payload) {\n\t\tthis.logger.debug(`Event '${payload.event}' received from '${payload.sender}' node` + (payload.groups ? ` in '${payload.groups.join(\", \")}' group(s)` : \"\") + \".\");\n\n\t\tif (!this.broker.started) {\n\t\t\tthis.logger.warn(`Incoming '${payload.event}' event from '${payload.sender}' node is dropped, because broker is stopped.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Create caller context\n\t\tconst ctx = new this.broker.ContextFactory(this.broker);\n\t\tctx.id = payload.id;\n\t\tctx.eventName = payload.event;\n\t\tctx.setParams(payload.data, this.broker.options.contextParamsCloning);\n\t\tctx.eventGroups = payload.groups;\n\t\tctx.eventType = payload.broadcast ? \"broadcast\" : \"emit\";\n\t\tctx.meta = payload.meta || {};\n\t\tctx.level = payload.level;\n\t\tctx.tracing = !!payload.tracing;\n\t\tctx.parentID = payload.parentID;\n\t\tctx.requestID = payload.requestID;\n\t\tctx.caller = payload.caller;\n\t\tctx.nodeID = payload.sender;\n\n\t\tthis.broker.emitLocalServices(ctx);\n\t}\n\n\t/**\n\t * Handle incoming request\n\t *\n\t * @param {Object} payload\n\t *\n\t * @memberof Transit\n\t */\n\trequestHandler(payload) {\n\t\tthis.logger.debug(`<= Request '${payload.action}' received from '${payload.sender}' node.`);\n\n\t\ttry {\n\t\t\tif (!this.broker.started) {\n\t\t\t\tthis.logger.warn(`Incoming '${payload.action}' request from '${payload.sender}' node is dropped because broker is stopped.`);\n\t\t\t\tthrow new E.ServiceNotAvailableError({ action: payload.action, nodeID: this.nodeID });\n\t\t\t}\n\n\t\t\tlet pass;\n\t\t\tif (payload.stream !== undefined) {\n\t\t\t\tpass = this._handleIncomingRequestStream(payload);\n\t\t\t\tif (pass === null) // eslint-disable-line security/detect-possible-timing-attacks\n\t\t\t\t\treturn this.Promise.resolve();\n\t\t\t}\n\n\t\t\tconst endpoint = this.broker._getLocalActionEndpoint(payload.action);\n\n\t\t\t// Recreate caller context\n\t\t\tconst ctx = new this.broker.ContextFactory(this.broker);\n\t\t\tctx.setEndpoint(endpoint);\n\t\t\tctx.id = payload.id;\n\t\t\tctx.setParams(pass ? pass : payload.params, this.broker.options.contextParamsCloning);\n\t\t\tctx.parentID = payload.parentID;\n\t\t\tctx.requestID = payload.requestID;\n\t\t\tctx.caller = payload.caller;\n\t\t\tctx.meta = payload.meta || {};\n\t\t\tctx.level = payload.level;\n\t\t\tctx.tracing = payload.tracing;\n\t\t\tctx.nodeID = payload.sender;\n\n\t\t\tif (payload.timeout != null)\n\t\t\t\tctx.options.timeout = payload.timeout;\n\n\t\t\tconst p = endpoint.action.handler(ctx);\n\t\t\t// Pointer to Context\n\t\t\tp.ctx = ctx;\n\n\t\t\treturn p\n\t\t\t\t.then(res => this.sendResponse(payload.sender, payload.id, ctx.meta, res, null))\n\t\t\t\t.catch(err => this.sendResponse(payload.sender, payload.id, ctx.meta, null, err));\n\n\t\t} catch (err) {\n\t\t\treturn this.sendResponse(payload.sender, payload.id, payload.meta, null, err);\n\t\t}\n\t}\n\n\t/**\n\t * Handle incoming request stream.\n\t *\n\t * @param {Object} payload\n\t * @returns {Stream}\n\t */\n\t_handleIncomingRequestStream(payload) {\n\t\tlet pass = this.pendingReqStreams.get(payload.id);\n\t\tlet isNew = false;\n\n\t\tif (!payload.stream && !pass) {\n\t\t\t// It is not a stream data\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!pass) {\n\t\t\tisNew = true;\n\t\t\tthis.logger.debug(`<= New stream is received from '${payload.sender}'. Seq: ${payload.seq}`);\n\n\t\t\t// Create a new pass stream\n\t\t\tpass = new Transform({\n\t\t\t\tobjectMode: payload.meta && payload.meta[\"$streamObjectMode\"],\n\t\t\t\ttransform: function(chunk, encoding, done) {\n\t\t\t\t\tthis.push(chunk);\n\t\t\t\t\treturn done();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpass.$prevSeq = -1;\n\t\t\tpass.$pool = new Map();\n\n\t\t\tthis.pendingReqStreams.set(payload.id, pass);\n\t\t}\n\n\t\tif (payload.seq > pass.$prevSeq + 1) {\n\t\t\t// Some chunks are late. Store these chunks.\n\t\t\tthis.logger.info(`Put the chunk into pool (size: ${pass.$pool.size}). Seq: ${payload.seq}`);\n\n\t\t\tpass.$pool.set(payload.seq, payload);\n\n\t\t\t// TODO: start timer.\n\t\t\t// TODO: check length of pool.\n\t\t\t// TODO: reset seq\n\n\t\t\treturn isNew ? pass : null;\n\t\t}\n\n\t\t// the next stream chunk received\n\t\tpass.$prevSeq = payload.seq;\n\n\t\tif (pass.$prevSeq > 0) {\n\t\t\tif (!payload.stream) {\n\n\t\t\t\t// Check stream error\n\t\t\t\tif (payload.meta && payload.meta[\"$streamError\"]) {\n\t\t\t\t\tpass.emit(\"error\", this._createErrFromPayload(payload.meta[\"$streamError\"], payload.sender));\n\t\t\t\t}\n\n\t\t\t\tthis.logger.debug(`<= Stream closing is received from '${payload.sender}'. Seq: ${payload.seq}`);\n\n\t\t\t\t// End of stream\n\t\t\t\tpass.end();\n\n\t\t\t\t// Remove pending request stream\n\t\t\t\tthis.pendingReqStreams.delete(payload.id);\n\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\t\t\t\tthis.logger.debug(`<= Stream chunk is received from '${payload.sender}'. Seq: ${payload.seq}`);\n\t\t\t\tpass.write(payload.params.type === \"Buffer\" ? Buffer.from(payload.params.data) : payload.params);\n\t\t\t}\n\t\t}\n\n\t\t// Check newer chunks in the pool\n\t\tif (pass.$pool.size > 0) {\n\t\t\tthis.logger.warn(`Has stored packets. Size: ${pass.$pool.size}`);\n\t\t\tconst nextSeq = pass.$prevSeq + 1;\n\t\t\tconst nextPacket = pass.$pool.get(nextSeq);\n\t\t\tif (nextPacket) {\n\t\t\t\tpass.$pool.delete(nextSeq);\n\t\t\t\tsetImmediate(() => this.requestHandler(nextPacket));\n\t\t\t}\n\t\t}\n\n\t\treturn isNew ? pass : null;\n\t}\n\n\t/**\n\t * Create an Error instance from payload ata\n\t * @param {Object} error\n\t * @param {String} sender\n\t */\n\t_createErrFromPayload(error, sender) {\n\t\tlet err = E.recreateError(error);\n\t\tif (!err) {\n\t\t\terr = new Error(error.message);\n\t\t\terr.name = error.name;\n\t\t\terr.code = error.code;\n\t\t\terr.type = error.type;\n\t\t\terr.data = error.data;\n\t\t}\n\t\terr.retryable = error.retryable;\n\t\terr.nodeID = error.nodeID || sender;\n\n\t\tif (error.stack)\n\t\t\terr.stack = error.stack;\n\n\t\treturn err;\n\t}\n\n\t/**\n\t * Process incoming response of request\n\t *\n\t * @param {Object} packet\n\t *\n\t * @memberof Transit\n\t */\n\tresponseHandler(packet) {\n\t\tconst id = packet.id;\n\t\tconst req = this.pendingRequests.get(id);\n\n\t\t// If not exists (timed out), we skip response processing\n\t\tif (req == null) {\n\t\t\tthis.logger.debug(\"Orphan response is received. Maybe the request is timed out earlier. ID:\", packet.id, \", Sender:\", packet.sender);\n\t\t\tthis.metrics.increment(METRIC.MOLECULER_TRANSIT_ORPHAN_RESPONSE_TOTAL);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.logger.debug(`<= Response '${req.action.name}' is received from '${packet.sender}'.`);\n\n\t\t// Update nodeID in context (if it uses external balancer)\n\t\treq.ctx.nodeID = packet.sender;\n\n\t\t// Merge response meta with original meta\n\t\tObject.assign(req.ctx.meta || {}, packet.meta || {});\n\n\t\t// Handle stream response\n\t\tif (packet.stream != null) {\n\t\t\tif (this._handleIncomingResponseStream(packet, req))\n\t\t\t\treturn;\n\t\t}\n\n\t\t// Remove pending request\n\t\tthis.removePendingRequest(id);\n\n\t\tif (!packet.success) {\n\t\t\treq.reject(this._createErrFromPayload(packet.error, packet.sender));\n\t\t} else {\n\t\t\treq.resolve(packet.data);\n\t\t}\n\t}\n\n\t/**\n\t * Handle incoming response stream.\n\t *\n\t * @param {Object} packet\n\t * @param {Object} req\n\t */\n\t_handleIncomingResponseStream(packet, req) {\n\t\tlet pass = this.pendingResStreams.get(packet.id);\n\t\tif (!pass && !packet.stream)\n\t\t\treturn false;\n\n\t\tif (!pass) {\n\t\t\tthis.logger.debug(`<= New stream is received from '${packet.sender}'. Seq: ${packet.seq}`);\n\n\t\t\tpass = new Transform({\n\t\t\t\tobjectMode: packet.meta && packet.meta[\"$streamObjectMode\"],\n\t\t\t\ttransform: function(chunk, encoding, done) {\n\t\t\t\t\tthis.push(chunk);\n\t\t\t\t\treturn done();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpass.$prevSeq = -1;\n\t\t\tpass.$pool = new Map();\n\n\t\t\tthis.pendingResStreams.set(packet.id, pass);\n\n\t\t\treq.resolve(pass);\n\t\t}\n\n\t\tif (packet.seq > pass.$prevSeq + 1) {\n\t\t\t// Some chunks are late. Store these chunks.\n\t\t\tthis.logger.info(`Put the chunk into pool (size: ${pass.$pool.size}). Seq: ${packet.seq}`);\n\n\t\t\tpass.$pool.set(packet.seq, packet);\n\n\t\t\t// TODO: start timer.\n\t\t\t// TODO: check length of pool.\n\t\t\t// TODO: resetting seq.\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// the next stream chunk received\n\t\tpass.$prevSeq = packet.seq;\n\n\t\tif (pass.$prevSeq > 0) {\n\n\t\t\tif (!packet.stream) {\n\t\t\t\t// Received error?\n\t\t\t\tif (!packet.success)\n\t\t\t\t\tpass.emit(\"error\", this._createErrFromPayload(packet.error, packet.sender));\n\n\t\t\t\tthis.logger.debug(`<= Stream closing is received from '${packet.sender}'. Seq: ${packet.seq}`);\n\n\t\t\t\t// End of stream\n\t\t\t\tpass.end();\n\n\t\t\t\t// Remove pending request\n\t\t\t\tthis.removePendingRequest(packet.id);\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\t\t\t\t// stream chunk\n\t\t\t\tthis.logger.debug(`<= Stream chunk is received from '${packet.sender}'. Seq: ${packet.seq}`);\n\t\t\t\tpass.write(packet.data.type === \"Buffer\" ? Buffer.from(packet.data.data):packet.data);\n\t\t\t}\n\t\t}\n\n\t\t// Check newer chunks in the pool\n\t\tif (pass.$pool.size > 0) {\n\t\t\tthis.logger.warn(`Has stored packets. Size: ${pass.$pool.size}`);\n\t\t\tconst nextSeq = pass.$prevSeq + 1;\n\t\t\tconst nextPacket = pass.$pool.get(nextSeq);\n\t\t\tif (nextPacket) {\n\t\t\t\tpass.$pool.delete(nextSeq);\n\t\t\t\tsetImmediate(() => this.responseHandler(nextPacket));\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Send a request to a remote service. It returns a Promise\n\t * what will be resolved when the response received.\n\t *\n\t * @param {<Context>} ctx Context of request\n\t * @returns {Promise}\n\t *\n\t * @memberof Transit\n\t */\n\trequest(ctx) {\n\t\tif (this.opts.maxQueueSize && this.pendingRequests.size >= this.opts.maxQueueSize)\n\t\t\t/* istanbul ignore next */\n\t\t\treturn this.Promise.reject(new E.QueueIsFullError({\n\t\t\t\taction: ctx.action.name,\n\t\t\t\tnodeID: this.nodeID,\n\t\t\t\tsize: this.pendingRequests.size,\n\t\t\t\tlimit: this.opts.maxQueueSize\n\t\t\t}));\n\n\t\t// Expanded the code that v8 can optimize it.  (TryCatchStatement disable optimizing)\n\t\treturn new this.Promise((resolve, reject) => this._sendRequest(ctx, resolve, reject));\n\t}\n\n\t/**\n\t * Send a remote request\n\t *\n\t * @param {<Context>} ctx      Context of request\n\t * @param {Function} resolve   Resolve of Promise\n\t * @param {Function} reject    Reject of Promise\n\t *\n\t * @memberof Transit\n\t */\n\t_sendRequest(ctx, resolve, reject) {\n\t\tconst isStream = ctx.params && ctx.params.readable === true && typeof ctx.params.on === \"function\" && typeof ctx.params.pipe === \"function\";\n\n\t\tconst request = {\n\t\t\taction: ctx.action,\n\t\t\tnodeID: ctx.nodeID,\n\t\t\tctx,\n\t\t\tresolve,\n\t\t\treject,\n\t\t\tstream: isStream // ???\n\t\t};\n\n\t\tconst payload = {\n\t\t\tid: ctx.id,\n\t\t\taction: ctx.action.name,\n\t\t\tparams: isStream ? null : ctx.params,\n\t\t\tmeta: ctx.meta,\n\t\t\ttimeout: ctx.options.timeout,\n\t\t\tlevel: ctx.level,\n\t\t\ttracing: ctx.tracing,\n\t\t\tparentID: ctx.parentID,\n\t\t\trequestID: ctx.requestID,\n\t\t\tcaller: ctx.caller,\n\t\t\tstream: isStream,\n\t\t};\n\n\t\tif (payload.stream) {\n\t\t\tif (ctx.params.readableObjectMode === true || (ctx.params._readableState && ctx.params._readableState.objectMode === true)) {\n\t\t\t\tpayload.meta = payload.meta || {};\n\t\t\t\tpayload.meta[\"$streamObjectMode\"] = true;\n\t\t\t}\n\t\t\tpayload.seq = 0;\n\t\t}\n\n\t\tconst packet = new Packet(P.PACKET_REQUEST, ctx.nodeID, payload);\n\n\t\tconst nodeName = ctx.nodeID ? `'${ctx.nodeID}'` : \"someone\";\n\t\tthis.logger.debug(`=> Send '${ctx.action.name}' request to ${nodeName} node.`);\n\n\t\tconst publishCatch = /* istanbul ignore next */ err => this.logger.error(`Unable to send '${ctx.action.name}' request to ${nodeName} node.`, err);\n\n\t\t// Add to pendings\n\t\tthis.pendingRequests.set(ctx.id, request);\n\n\t\t// Publish request\n\t\treturn this.publish(packet)\n\t\t\t.then(() => {\n\t\t\t\tif (isStream) {\n\t\t\t\t\t// Skip to send ctx.meta with chunks because it doesn't appear on the remote side.\n\t\t\t\t\tpayload.meta = {};\n\t\t\t\t\t// Still send information about objectMode in case of packets are received in wrong order\n\t\t\t\t\tif (ctx.params.readableObjectMode === true || (ctx.params._readableState && ctx.params._readableState.objectMode === true)) {\n\t\t\t\t\t\tpayload.meta[\"$streamObjectMode\"] = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst stream = ctx.params;\n\t\t\t\t\tstream.on(\"data\", (chunk) => {\n\t\t\t\t\t\tstream.pause();\n\t\t\t\t\t\tconst chunks = [];\n\t\t\t\t\t\tif (chunk instanceof Buffer && this.opts.maxChunkSize > 0 && chunk.length > this.opts.maxChunkSize) {\n\t\t\t\t\t\t\tlet len = chunk.length;\n\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\twhile (i < len) {\n\t\t\t\t\t\t\t\tchunks.push(chunk.slice(i, i += this.opts.maxChunkSize));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const ch of chunks) {\n\t\t\t\t\t\t\tconst copy = Object.assign({}, payload);\n\t\t\t\t\t\t\tcopy.seq = ++payload.seq;\n\t\t\t\t\t\t\tcopy.stream = true;\n\t\t\t\t\t\t\tcopy.params = ch;\n\n\t\t\t\t\t\t\tthis.logger.debug(`=> Send stream chunk to ${nodeName} node. Seq: ${copy.seq}`);\n\n\t\t\t\t\t\t\tthis.publish(new Packet(P.PACKET_REQUEST, ctx.nodeID, copy))\n\t\t\t\t\t\t\t\t.catch(publishCatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstream.resume();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t});\n\n\t\t\t\t\tstream.on(\"end\", () => {\n\t\t\t\t\t\tconst copy = Object.assign({}, payload);\n\t\t\t\t\t\tcopy.seq = ++payload.seq;\n\t\t\t\t\t\tcopy.params = null;\n\t\t\t\t\t\tcopy.stream = false;\n\n\t\t\t\t\t\tthis.logger.debug(`=> Send stream closing to ${nodeName} node. Seq: ${copy.seq}`);\n\n\t\t\t\t\t\treturn this.publish(new Packet(P.PACKET_REQUEST, ctx.nodeID, copy))\n\t\t\t\t\t\t\t.catch(publishCatch);\n\t\t\t\t\t});\n\n\t\t\t\t\tstream.on(\"error\", err => {\n\t\t\t\t\t\tconst copy = Object.assign({}, payload);\n\t\t\t\t\t\tcopy.seq = ++payload.seq;\n\t\t\t\t\t\tcopy.stream = false;\n\t\t\t\t\t\tcopy.meta[\"$streamError\"] = this._createPayloadErrorField(err);\n\t\t\t\t\t\tcopy.params = null;\n\n\t\t\t\t\t\tthis.logger.debug(`=> Send stream error to ${nodeName} node.`, copy.meta[\"$streamError\"]);\n\n\t\t\t\t\t\treturn this.publish(new Packet(P.PACKET_REQUEST, ctx.nodeID, copy))\n\t\t\t\t\t\t\t.catch(publishCatch);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tpublishCatch(err);\n\t\t\t\treject(err);\n\t\t\t});\n\t}\n\n\t/**\n\t * Send an event to a remote node.\n\t * The event is balanced by transporter\n\t *\n\t * @param {Context} ctx\n\t *\n\t * @memberof Transit\n\t */\n\tsendEvent(ctx) {\n\t\tconst groups = ctx.eventGroups;\n\t\tif (ctx.endpoint)\n\t\t\tthis.logger.debug(`=> Send '${ctx.eventName}' event to '${ctx.nodeID}' node` + (groups ? ` in '${groups.join(\", \")}' group(s)` : \"\") + \".\");\n\t\telse\n\t\t\tthis.logger.debug(`=> Send '${ctx.eventName}' event to '${groups.join(\", \")}' group(s).`);\n\n\t\treturn this.publish(new Packet(P.PACKET_EVENT, ctx.endpoint ? ctx.nodeID : null, {\n\t\t\tid: ctx.id,\n\t\t\tevent: ctx.eventName,\n\t\t\tdata: ctx.params,\n\t\t\tgroups,\n\t\t\tbroadcast: ctx.eventType == \"broadcast\",\n\t\t\tmeta: ctx.meta,\n\t\t\tlevel: ctx.level,\n\t\t\ttracing: ctx.tracing,\n\t\t\tparentID: ctx.parentID,\n\t\t\trequestID: ctx.requestID,\n\t\t\tcaller: ctx.caller,\n\t\t\tneedAck: ctx.needAck\n\t\t})).catch(/* istanbul ignore next */ err => this.logger.error(`Unable to send '${ctx.eventName}' event to groups.`, err));\n\t}\n\n\t/**\n\t * Remove a pending request\n\t *\n\t * @param {any} id\n\t *\n\t * @memberof Transit\n\t */\n\tremovePendingRequest(id) {\n\t\tthis.pendingRequests.delete(id);\n\n\t\tthis.pendingReqStreams.delete(id);\n\t\tthis.pendingResStreams.delete(id);\n\t}\n\n\t/**\n\t * Remove a pending request & streams\n\t *\n\t * @param {String} nodeID\n\t *\n\t * @memberof Transit\n\t */\n\tremovePendingRequestByNodeID(nodeID) {\n\t\tthis.logger.debug(`Remove pending requests of '${nodeID}' node.`);\n\t\tthis.pendingRequests.forEach((req, id) => {\n\t\t\tif (req.nodeID === nodeID) {\n\t\t\t\tthis.pendingRequests.delete(id);\n\n\t\t\t\t// Reject the request\n\t\t\t\treq.reject(new E.RequestRejectedError({\n\t\t\t\t\taction: req.action.name,\n\t\t\t\t\tnodeID: req.nodeID\n\t\t\t\t}));\n\n\t\t\t\tthis.pendingReqStreams.delete(id);\n\t\t\t\tthis.pendingResStreams.delete(id);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Create error field in outgoing payload\n\t *\n\t * @param {Error} err\n\t * @returns {Object}\n\t * @memberof Transit\n\t */\n\t_createPayloadErrorField(err) {\n\t\treturn {\n\t\t\tname: err.name,\n\t\t\tmessage: err.message,\n\t\t\tnodeID: err.nodeID || this.nodeID,\n\t\t\tcode: err.code,\n\t\t\ttype: err.type,\n\t\t\tretryable: err.retryable,\n\t\t\tstack: err.stack,\n\t\t\tdata: err.data\n\t\t};\n\t}\n\n\t/**\n\t * Send back the response of request\n\t *\n\t * @param {String} nodeID\n\t * @param {String} id\n\t * @param {any} meta\n\t * @param {any} data\n\t * @param {Error} err\n\t *\n\t * @memberof Transit\n\t */\n\tsendResponse(nodeID, id, meta, data, err) {\n\t\t// Publish the response\n\t\tconst payload = {\n\t\t\tid: id,\n\t\t\tmeta: meta,\n\t\t\tsuccess: err == null,\n\t\t\tdata: data\n\t\t};\n\n\t\tif (err)\n\t\t\tpayload.error = this._createPayloadErrorField(err);\n\n\t\tconst publishCatch = /* istanbul ignore next */ err => this.logger.error(`Unable to send '${id}' response to '${nodeID}' node.`, err);\n\n\t\tif (data && data.readable === true && typeof data.on === \"function\" && typeof data.pipe === \"function\") {\n\t\t\t// Streaming response\n\t\t\tpayload.stream = true;\n\t\t\tif (data.readableObjectMode === true || (data._readableState && data._readableState.objectMode === true)) {\n\t\t\t\tpayload.meta = payload.meta || {};\n\t\t\t\tpayload.meta[\"$streamObjectMode\"] = true;\n\t\t\t}\n\t\t\tpayload.seq = 0;\n\n\t\t\tconst stream = data;\n\t\t\tstream.pause();\n\n\t\t\tstream.on(\"data\", (chunk) => {\n\t\t\t\tstream.pause();\n\t\t\t\tconst chunks = [];\n\t\t\t\tif (chunk instanceof Buffer && this.opts.maxChunkSize > 0 && chunk.length > this.opts.maxChunkSize) {\n\t\t\t\t\tlet len = chunk.length;\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (i < len) {\n\t\t\t\t\t\tchunks.push(chunk.slice(i, i += this.opts.maxChunkSize));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t\tfor (const ch of chunks) {\n\t\t\t\t\tconst copy = Object.assign({}, payload);\n\t\t\t\t\tcopy.seq = ++payload.seq;\n\t\t\t\t\tcopy.stream = true;\n\t\t\t\t\tcopy.data = ch;\n\n\t\t\t\t\tthis.logger.debug(`=> Send stream chunk to ${nodeID} node. Seq: ${copy.seq}`);\n\n\t\t\t\t\tthis.publish(new Packet(P.PACKET_RESPONSE, nodeID, copy))\n\t\t\t\t\t\t.catch(publishCatch);\n\t\t\t\t}\n\t\t\t\tstream.resume();\n\t\t\t\treturn;\n\t\t\t});\n\n\t\t\tstream.on(\"end\", () => {\n\t\t\t\tconst copy = Object.assign({}, payload);\n\t\t\t\tcopy.stream = false;\n\t\t\t\tcopy.seq = ++payload.seq;\n\t\t\t\tcopy.data = null;\n\n\t\t\t\tthis.logger.debug(`=> Send stream closing to ${nodeID} node. Seq: ${copy.seq}`);\n\n\t\t\t\treturn this.publish(new Packet(P.PACKET_RESPONSE, nodeID, copy))\n\t\t\t\t\t.catch(publishCatch);\n\t\t\t});\n\n\t\t\tstream.on(\"error\", err => {\n\t\t\t\tconst copy = Object.assign({}, payload);\n\t\t\t\tcopy.stream = false;\n\t\t\t\tcopy.seq = ++payload.seq;\n\t\t\t\tif (err) {\n\t\t\t\t\tcopy.success = false;\n\t\t\t\t\tcopy.error = this._createPayloadErrorField(err);\n\t\t\t\t}\n\n\t\t\t\tthis.logger.debug(`=> Send stream error to ${nodeID} node.`, copy.error);\n\n\t\t\t\treturn this.publish(new Packet(P.PACKET_RESPONSE, nodeID, copy))\n\t\t\t\t\t.catch(publishCatch);\n\t\t\t});\n\n\t\t\tpayload.data = null;\n\t\t\treturn this.publish(new Packet(P.PACKET_RESPONSE, nodeID, payload))\n\t\t\t\t.then(() => {\n\t\t\t\t\tif (payload.stream)\n\t\t\t\t\t\tstream.resume();\n\t\t\t\t})\n\t\t\t\t.catch(publishCatch);\n\n\t\t}\n\n\t\treturn this.publish(new Packet(P.PACKET_RESPONSE, nodeID, payload))\n\t\t\t.catch(publishCatch);\n\t}\n\n\t/**\n\t * Discover other nodes. It will be called after success connect.\n\t *\n\t * @memberof Transit\n\t */\n\tdiscoverNodes() {\n\t\treturn this.publish(new Packet(P.PACKET_DISCOVER))\n\t\t\t.catch(/* istanbul ignore next */ err => this.logger.error(\"Unable to send DISCOVER packet.\", err));\n\t}\n\n\t/**\n\t * Discover a node. It will be called if we got message from an unknown node.\n\t *\n\t * @memberof Transit\n\t */\n\tdiscoverNode(nodeID) {\n\t\treturn this.publish(new Packet(P.PACKET_DISCOVER, nodeID))\n\t\t\t.catch(/* istanbul ignore next */ err => this.logger.error(`Unable to send DISCOVER packet to '${nodeID}' node.`, err));\n\t}\n\n\t/**\n\t * Send node info package to other nodes.\n\t *\n\t * @memberof Transit\n\t */\n\tsendNodeInfo(info, nodeID) {\n\t\tif (!this.connected || !this.isReady) return this.Promise.resolve();\n\n\t\tconst p = !nodeID && this.broker.options.disableBalancer ? this.tx.makeBalancedSubscriptions() : this.Promise.resolve();\n\t\treturn p.then(() => this.publish(new Packet(P.PACKET_INFO, nodeID, {\n\t\t\tservices: info.services,\n\t\t\tipList: info.ipList,\n\t\t\thostname: info.hostname,\n\t\t\tclient: info.client,\n\t\t\tconfig: info.config,\n\t\t\tinstanceID: this.broker.instanceID,\n\t\t\tmetadata: info.metadata,\n\t\t\tseq: info.seq\n\t\t}))).catch(/* istanbul ignore next */ err => this.logger.error(`Unable to send INFO packet to '${nodeID}' node.`, err));\n\n\t}\n\n\t/**\n\t * Send ping to a node (or all nodes if nodeID is null)\n\t *\n\t * @param {String} nodeID\n\t * @param {String} id\n\t * @returns\n\t * @memberof Transit\n\t */\n\tsendPing(nodeID, id) {\n\t\treturn this.publish(new Packet(P.PACKET_PING, nodeID, { time: Date.now(), id: id || this.broker.generateUid() }))\n\t\t\t.catch(/* istanbul ignore next */ err => this.logger.error(`Unable to send PING packet to '${nodeID}' node.`, err));\n\t}\n\n\t/**\n\t * Send back pong response\n\t *\n\t * @param {Object} payload\n\t * @returns\n\t * @memberof Transit\n\t */\n\tsendPong(payload) {\n\t\treturn this.publish(new Packet(P.PACKET_PONG, payload.sender, {\n\t\t\ttime: payload.time,\n\t\t\tid: payload.id,\n\t\t\tarrived: Date.now()\n\t\t})).catch(/* istanbul ignore next */ err => this.logger.error(`Unable to send PONG packet to '${payload.sender}' node.`, err));\n\t}\n\n\t/**\n\t * Process incoming PONG packet.\n\t * Measure ping time & current time difference.\n\t *\n\t * @param {Object} payload\n\t * @memberof Transit\n\t */\n\tprocessPong(payload) {\n\t\tconst now = Date.now();\n\t\tconst elapsedTime = now - payload.time;\n\t\tconst timeDiff = Math.round(now - payload.arrived - elapsedTime / 2);\n\n\t\t// this.logger.debug(`PING-PONG from '${payload.sender}' - Time: ${elapsedTime}ms, Time difference: ${timeDiff}ms`);\n\n\t\tthis.broker.broadcastLocal(\"$node.pong\", { nodeID: payload.sender, elapsedTime, timeDiff, id: payload.id });\n\n\t\tthis.metrics.set(METRIC.MOLECULER_TRANSIT_PONG_TIME, elapsedTime, { targetNodeID: payload.sender });\n\t\tthis.metrics.set(METRIC.MOLECULER_TRANSIT_PONG_SYSTIME_DIFF, timeDiff, { targetNodeID: payload.sender });\n\t}\n\n\t/**\n\t * Send a node heartbeat. It will be called with timer from local Discoverer.\n\t *\n\t * @params {Node} localNode\n\t * @memberof Transit\n\t */\n\tsendHeartbeat(localNode) {\n\t\treturn this.publish(new Packet(P.PACKET_HEARTBEAT, null, {\n\t\t\tcpu: localNode.cpu\n\t\t})).catch(/* istanbul ignore next */ err => this.logger.error(\"Unable to send HEARTBEAT packet.\", err));\n\n\t}\n\n\t/**\n\t * Subscribe via transporter\n\t *\n\t * @param {String} topic\n\t * @param {String=} nodeID\n\t *\n\t * @deprecated\n\t * @memberof Transit\n\t */\n\tsubscribe(topic, nodeID) {\n\t\treturn this.tx.subscribe(topic, nodeID);\n\t}\n\n\t/**\n\t * Publish via transporter\n\t *\n\t * @param {Packet} Packet\n\t *\n\t * @memberof Transit\n\t */\n\tpublish(packet) {\n\t\tif (this.subscribing) {\n\t\t\treturn this.subscribing\n\t\t\t\t.then(() => {\n\t\t\t\t\treturn this.tx.prepublish(packet);\n\t\t\t\t});\n\t\t}\n\t\treturn this.tx.prepublish(packet);\n\t}\n\n}\n\nmodule.exports = Transit;\n"],"names":["Packet","P","Transform","require$$0","METRIC","require$$1","[object Object]","broker","transporter","opts","this","Promise","logger","getLogger","nodeID","metrics","instanceID","tx","discoverer","registry","pendingRequests","Map","pendingReqStreams","pendingResStreams","stat","packets","sent","count","bytes","received","connected","disconnecting","isReady","wrappedMessageHandler","cmd","packet","messageHandler","publish","wrapMethod","init","afterConnect","bind","send","receive","reverse","__connectResolve","registerMoleculerMetrics","isMetricsEnabled","register","name","MOLECULER_TRANSIT_READY","type","TYPE_GAUGE","description","set","MOLECULER_TRANSIT_CONNECTED","MOLECULER_TRANSIT_PONG_TIME","labelNames","MOLECULER_TRANSIT_PONG_SYSTIME_DIFF","MOLECULER_TRANSIT_ORPHAN_RESPONSE_TOTAL","TYPE_COUNTER","wasReconnect","resolve","then","sendLocalNodeInfo","makeSubscriptions","discoverAllNodes","delay","broadcastLocal","info","doConnect","reconnectStarted","errorHandler","err","warn","message","debug","disableReconnect","setTimeout","connect","catch","graceFul","localNodeDisconnected","disconnect","localNodeReady","PACKET_DISCONNECT","subscribing","PACKET_EVENT","PACKET_REQUEST","PACKET_RESPONSE","PACKET_DISCOVER","PACKET_INFO","PACKET_HEARTBEAT","PACKET_PING","PACKET_PONG","payload","E","MoleculerServerError","ver","PROTOCOL_VERSION","disableVersionCheck","ProtocolVersionMismatchError","sender","actual","fatal","requestHandler","responseHandler","eventHandler","processRemoteNodeInfo","remoteNodeDisconnected","heartbeatReceived","sendPong","processPong","error","event","groups","join","started","ctx","ContextFactory","id","eventName","setParams","data","options","contextParamsCloning","eventGroups","eventType","broadcast","meta","level","tracing","parentID","requestID","caller","emitLocalServices","action","ServiceNotAvailableError","pass","undefined","stream","_handleIncomingRequestStream","endpoint","_getLocalActionEndpoint","setEndpoint","params","timeout","p","handler","res","sendResponse","get","isNew","seq","objectMode","transform","chunk","encoding","done","push","$prevSeq","$pool","size","emit","_createErrFromPayload","end","delete","write","Buffer","from","nextSeq","nextPacket","setImmediate","recreateError","Error","code","retryable","stack","req","increment","Object","assign","_handleIncomingResponseStream","removePendingRequest","success","reject","maxQueueSize","QueueIsFullError","limit","_sendRequest","isStream","readable","on","pipe","request","readableObjectMode","_readableState","nodeName","publishCatch","pause","chunks","maxChunkSize","length","len","i","slice","ch","copy","resume","_createPayloadErrorField","needAck","forEach","RequestRejectedError","disableBalancer","makeBalancedSubscriptions","services","ipList","hostname","client","config","metadata","time","Date","now","generateUid","arrived","elapsedTime","timeDiff","Math","round","targetNodeID","localNode","cpu","topic","subscribe","prepublish"],"mappings":"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"}