{"version":3,"file":"middleware.js","sources":["../../../../src/moleculer/src/middleware.js"],"sourcesContent":["/*\n * moleculer\n * Copyright (c) 2019 MoleculerJS (https://github.com/moleculerjs/moleculer)\n * MIT Licensed\n */\n\n\"use strict\";\n\nconst _ \t\t\t= require(\"lodash\");\nconst Middlewares \t= require(\"./middlewares\");\nconst { BrokerOptionsError } = require(\"./errors\");\nconst { isObject, isFunction, isString }\t= require(\"./utils\");\n\nclass MiddlewareHandler {\n\n\tconstructor(broker) {\n\t\tthis.broker = broker;\n\n\t\tthis.list = [];\n\n\t\tthis.registeredHooks = {};\n\t}\n\n\tadd(mw) {\n\t\tif (!mw) return;\n\n\t\tif (isString(mw)) {\n\t\t\tconst found = _.get(Middlewares, mw);\n\t\t\tif (!found)\n\t\t\t\tthrow new BrokerOptionsError(`Invalid built-in middleware type '${mw}'.`, { type: mw });\n\t\t\tmw = found;\n\t\t}\n\n\t\tif (isFunction(mw))\n\t\t\tmw = mw.call(this.broker, this.broker);\n\n\t\tif (!isObject(mw))\n\t\t\tthrow new BrokerOptionsError(`Invalid middleware type '${typeof mw}'. Accepted only Object of Function.`, { type: typeof mw });\n\n\t\tObject.keys(mw).forEach(key => {\n\t\t\tif (isFunction(mw[key])) {\n\t\t\t\tif (Array.isArray(this.registeredHooks[key]))\n\t\t\t\t\tthis.registeredHooks[key].push(mw[key]);\n\t\t\t\telse\n\t\t\t\t\tthis.registeredHooks[key] = [mw[key]];\n\t\t\t}\n\t\t});\n\n\t\tthis.list.push(mw);\n\t}\n\n\t/**\n\t * Wrap a handler\n\t *\n\t * @param {string} method\n\t * @param {Function} handler\n\t * @param {Object} def\n\t * @returns {Function}\n\t * @memberof MiddlewareHandler\n\t */\n\twrapHandler(method, handler, def) {\n\t\tif (this.registeredHooks[method] && this.registeredHooks[method].length) {\n\t\t\thandler = this.registeredHooks[method].reduce((handler, fn) => {\n\t\t\t\treturn fn.call(this.broker, handler, def);\n\t\t\t}, handler);\n\t\t}\n\n\t\treturn handler;\n\t}\n\n\t/**\n\t * Call a handler asynchronously in all middlewares\n\t *\n\t * @param {String} method\n\t * @param {Array<any>} args\n\t * @param {Object} opts\n\t * @returns {Promise}\n\t * @memberof MiddlewareHandler\n\t */\n\tcallHandlers(method, args, opts = {}) {\n\t\tif (this.registeredHooks[method] && this.registeredHooks[method].length) {\n\t\t\tconst list = opts.reverse ? Array.from(this.registeredHooks[method]).reverse() : this.registeredHooks[method];\n\t\t\treturn list.reduce((p, fn) => p.then(() => fn.apply(this.broker, args)), this.broker.Promise.resolve());\n\t\t}\n\n\t\treturn this.broker.Promise.resolve();\n\t}\n\n\t/**\n\t * Call a handler synchronously in all middlewares\n\t *\n\t * @param {String} method\n\t * @param {Array<any>} args\n\t * @param {Object} opts\n\t * @returns {Array<any}\n\t * @memberof MiddlewareHandler\n\t */\n\tcallSyncHandlers(method, args, opts = {}) {\n\t\tif (this.registeredHooks[method] && this.registeredHooks[method].length) {\n\t\t\tconst list = opts.reverse ? Array.from(this.registeredHooks[method]).reverse() : this.registeredHooks[method];\n\t\t\treturn list.map(fn => fn.apply(this.broker, args));\n\t\t}\n\t\treturn;\n\t}\n\n\t/**\n\t * Get count of registered middlewares\n\t *\n\t * @returns {Number}\n\t * @memberof MiddlewareHandler\n\t */\n\tcount() {\n\t\treturn this.list.length;\n\t}\n\n\t/**\n\t * Wrap a method\n\t *\n\t * @param {string} method\n\t * @param {Function} handler\n\t * @param {any} bindTo\n\t * @param {Object} opts\n\t * @returns {Function}\n\t * @memberof MiddlewareHandler\n\t */\n\twrapMethod(method, handler, bindTo = this.broker, opts = {}) {\n\t\tif (this.registeredHooks[method] && this.registeredHooks[method].length) {\n\t\t\tconst list = opts.reverse ? Array.from(this.registeredHooks[method]).reverse() : this.registeredHooks[method];\n\t\t\thandler = list.reduce((next, fn) => fn.call(bindTo, next), handler.bind(bindTo));\n\t\t}\n\n\t\treturn handler;\n\t}\n\n}\n\nmodule.exports = MiddlewareHandler;\n\n/*\n{\n    // After broker is created\n    created(broker) {\n\t\treturn;\n    },\n\n    // Wrap local action handlers (legacy middleware handler)\n    localAction(next, action) {\n\t\treturn ctx => {\n\t\t\treturn next(ctx);\n\t\t};\n    },\n\n    // Wrap remote action handlers\n    remoteAction(next, action) {\n\t\treturn ctx => {\n\t\t\treturn next(ctx);\n\t\t};\n    },\n\n\t// Wrap local event handlers\n\tlocalEvent(next, event) {\n\t\treturn (payload, sender, event) => {\n\t\t\treturn next(payload, sender, event);\n\t\t};\n\t},\n\n    // Wrap local method handlers\n    localMethod(next, method) {\n\t\treturn () => {\n\t\t\treturn next(...arguments);\n\t\t};\n\t},\n\n\t// Wrap broker.createService method\n\tcreateService(next) {\n\t\treturn (schema, schemaMods) => {\n\t\t\treturn next(schema, schemaMods);\n\t\t};\n\t},\n\n\t// Wrap broker.registerLocalService method\n\tregisterLocalService(next) {\n\t\treturn (svc) => {\n\t\t\treturn next(svc);\n\t\t};\n\t},\n\n\t// Wrap broker.destroyService method\n\tdestroyService(next) {\n\t\treturn (svc) => {\n\t\t\treturn next(svc);\n\t\t};\n\t},\n\n\t// Wrap broker.call method\n\tcall(next) {\n\t\treturn (actionName, params, opts) => {\n\t\t\treturn next(actionName, params, opts);\n\t\t};\n\t},\n\n\t// Wrap broker.mcall method\n\tmcall(next) {\n\t\treturn (def) => {\n\t\t\treturn next(def);\n\t\t};\n\t},\n\n    // Wrap broker.emit method\n    emit(next) {\n\t\treturn (event, payload) => {\n\t\t\treturn next(event, payload);\n\t\t};\n    },\n\n    // Wrap broker.broadcast method\n    broadcast(next) {\n\t\treturn (event, payload) => {\n\t\t\treturn next(event, payload);\n\t\t};\n    },\n\n    // Wrap broker.broadcastLocal method\n    broadcastLocal(next) {\n\t\treturn (event, payload) => {\n\t\t\treturn next(event, payload);\n\t\t};\n    },\n\n\t// While a new local service creating (after mixins are mixed)\n\tserviceCreating(service, schema) {\n\t\treturn;\n\t},\n\n\t// After a new local service created\n\tserviceCreated(service) {\n\t\treturn;\n\t},\n\n\t// Before a local service started\n\tserviceStarting(service) {\n\t\treturn Promise.resolve();\n\t},\n\n\t// After a local service started\n\tserviceStarted(service) {\n\t\treturn Promise.resolve();\n\t},\n\n\t// Before a local service stopping\n\tserviceStopping(service) {\n\t\treturn Promise.resolve();\n\t},\n\n\t// After a local service stopped\n\tserviceStopped(service) {\n\t\treturn Promise.resolve();\n\t},\n\n    // Before broker starting\n    starting(broker) {\n\t\treturn Promise.resolve();\n    },\n\n    // After broker started\n    started(broker) {\n\t\treturn Promise.resolve();\n    },\n\n    // Before broker stopping\n    stopping(broker) {\n\t\treturn Promise.resolve();\n    },\n\n    // After broker stopped\n    stopped(broker) {\n\t\treturn Promise.resolve();\n    },\n\n\t// When transit publishing a packet\n\ttransitPublish(next) {\n\t\treturn (packet) => {\n\t\t\treturn next(packet);\n\t\t};\n\t},\n\n\t// When transit receives & handles a packet\n\ttransitMessageHandler(next) {\n\t\treturn (cmd, packet) => {\n\t\t\treturn next(cmd, packet);\n\t\t};\n\t},\n\n\t// When transporter send data\n\ttransporterSend(next) {\n\t\treturn (topic, data, meta) => {\n\t\t\treturn next(topic, data, meta);\n\t\t};\n\t},\n\n\t// When transporter received data\n\ttransporterReceive(next) {\n\t\treturn (cmd, data, s) => {\n\t\t\treturn next(cmd, data, s);\n\t\t};\n\t},\n\n\t// When transporter received data\n\tnewLogEntry(type, args, bindings) {\n\t\t// Do something\n\t}\n}\n\n*/\n"],"names":["BrokerOptionsError","require$$0","isObject","isFunction","isString","require$$1","[object Object]","broker","this","list","registeredHooks","mw","found","_","get","Middlewares","type","call","Object","keys","forEach","key","Array","isArray","push","method","handler","def","length","reduce","fn","args","opts","reverse","from","p","then","apply","Promise","resolve","map","bindTo","next","bind"],"mappings":"iHAUA,MAAMA,mBAAEA,GAAuBC,GACzBC,SAAEA,EAAQC,WAAEA,EAAUC,SAAEA,GAAaC,QAE3C,MAECC,YAAYC,GACXC,KAAKD,OAASA,EAEdC,KAAKC,KAAO,GAEZD,KAAKE,gBAAkB,GAGxBJ,IAAIK,GACH,GAAKA,EAAL,CAEA,GAAIP,EAASO,GAAK,CACjB,MAAMC,EAAQC,EAAEC,IAAIC,EAAaJ,GACjC,IAAKC,EACJ,MAAM,IAAIZ,EAAmB,qCAAqCW,MAAQ,CAAEK,KAAML,IACnFA,EAAKC,EAMN,GAHIT,EAAWQ,KACdA,EAAKA,EAAGM,KAAKT,KAAKD,OAAQC,KAAKD,UAE3BL,EAASS,GACb,MAAM,IAAIX,EAAmB,mCAAmCW,wCAA0C,CAAEK,YAAaL,IAE1HO,OAAOC,KAAKR,GAAIS,SAAQC,IACnBlB,EAAWQ,EAAGU,MACbC,MAAMC,QAAQf,KAAKE,gBAAgBW,IACtCb,KAAKE,gBAAgBW,GAAKG,KAAKb,EAAGU,IAElCb,KAAKE,gBAAgBW,GAAO,CAACV,EAAGU,QAInCb,KAAKC,KAAKe,KAAKb,IAYhBL,YAAYmB,EAAQC,EAASC,GAO5B,OANInB,KAAKE,gBAAgBe,IAAWjB,KAAKE,gBAAgBe,GAAQG,SAChEF,EAAUlB,KAAKE,gBAAgBe,GAAQI,QAAO,CAACH,EAASI,IAChDA,EAAGb,KAAKT,KAAKD,OAAQmB,EAASC,IACnCD,IAGGA,EAYRpB,aAAamB,EAAQM,EAAMC,EAAO,IACjC,GAAIxB,KAAKE,gBAAgBe,IAAWjB,KAAKE,gBAAgBe,GAAQG,OAAQ,CAExE,OADaI,EAAKC,QAAUX,MAAMY,KAAK1B,KAAKE,gBAAgBe,IAASQ,UAAYzB,KAAKE,gBAAgBe,IAC1FI,QAAO,CAACM,EAAGL,IAAOK,EAAEC,MAAK,IAAMN,EAAGO,MAAM7B,KAAKD,OAAQwB,MAAQvB,KAAKD,OAAO+B,QAAQC,WAG9F,OAAO/B,KAAKD,OAAO+B,QAAQC,UAY5BjC,iBAAiBmB,EAAQM,EAAMC,EAAO,IACrC,GAAIxB,KAAKE,gBAAgBe,IAAWjB,KAAKE,gBAAgBe,GAAQG,OAAQ,CAExE,OADaI,EAAKC,QAAUX,MAAMY,KAAK1B,KAAKE,gBAAgBe,IAASQ,UAAYzB,KAAKE,gBAAgBe,IAC1Fe,KAAIV,GAAMA,EAAGO,MAAM7B,KAAKD,OAAQwB,MAW9CzB,QACC,OAAOE,KAAKC,KAAKmB,OAalBtB,WAAWmB,EAAQC,EAASe,EAASjC,KAAKD,OAAQyB,EAAO,IACxD,GAAIxB,KAAKE,gBAAgBe,IAAWjB,KAAKE,gBAAgBe,GAAQG,OAAQ,CAExEF,GADaM,EAAKC,QAAUX,MAAMY,KAAK1B,KAAKE,gBAAgBe,IAASQ,UAAYzB,KAAKE,gBAAgBe,IACvFI,QAAO,CAACa,EAAMZ,IAAOA,EAAGb,KAAKwB,EAAQC,IAAOhB,EAAQiB,KAAKF,IAGzE,OAAOf"}