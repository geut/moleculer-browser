import e from"lodash";import r from"../packets.js";import t from"../errors.js";import s from"../utils.js";const{flatten:i}=s,{BrokerDisconnectedError:n}=t;var o=class{constructor(e){this.opts=e,this.connected=!1,this.hasBuiltInBalancer=!1}init(e,r,t){e&&(this.transit=e,this.broker=e.broker,this.nodeID=e.nodeID,this.logger=this.broker.getLogger("transporter"),this.prefix="MOL",this.broker.namespace&&(this.prefix+="-"+this.broker.namespace)),this.messageHandler=r,this.afterConnect=t}connect(){throw new Error("Not implemented!")}onConnected(e){return this.connected=!0,this.afterConnect?this.afterConnect(e):this.broker.Promise.resolve()}disconnect(){throw new Error("Not implemented!")}makeSubscriptions(e){return this.broker.Promise.all(e.map((({cmd:e,nodeID:r})=>this.subscribe(e,r))))}incomingMessage(e,r){if(r)try{const t=this.deserialize(e,r);return this.messageHandler(e,t)}catch(t){this.logger.warn("Invalid incoming packet. Type:",e,t),this.logger.debug("Content:",r.toString?r.toString():r)}}receive(e,r){return this.incomingMessage(e,r)}subscribe(){throw new Error("Not implemented!")}subscribeBalancedRequest(){throw new Error("Not implemented!")}subscribeBalancedEvent(){throw new Error("Not implemented!")}unsubscribeFromBalancedCommands(){return this.broker.Promise.resolve()}publish(e){const r=this.getTopicName(e.type,e.target),t=this.serialize(e);return this.send(r,t,{packet:e})}publishBalancedEvent(e,t){const s=`${this.prefix}.${r.PACKET_EVENT}B.${t}.${e.payload.event}`,i=this.serialize(e);return this.send(s,i,{packet:e,balanced:!0})}publishBalancedRequest(e){const t=`${this.prefix}.${r.PACKET_REQUEST}B.${e.payload.action}`,s=this.serialize(e);return this.send(t,s,{packet:e,balanced:!0})}send(){throw new Error("Not implemented!")}getTopicName(e,r){return this.prefix+"."+e+(r?"."+r:"")}makeBalancedSubscriptions(){return this.hasBuiltInBalancer?this.unsubscribeFromBalancedCommands().then((()=>{const r=this.broker.getLocalNodeInfo().services;return this.broker.Promise.all(r.map((r=>{const t=[];return r.actions&&"object"==typeof r.actions&&t.push(Object.keys(r.actions).map((e=>this.subscribeBalancedRequest(e)))),r.events&&"object"==typeof r.events&&t.push(Object.keys(r.events).map((e=>{const t=r.events[e].group||r.name;this.subscribeBalancedEvent(e,t)}))),this.broker.Promise.all(e.compact(i(t,!0)))})))})):this.broker.Promise.resolve()}prepublish(e){if(!this.connected)return[r.PACKET_REQUEST,r.PACKET_EVENT,r.PACKET_PING].includes(e.type)?this.broker.Promise.reject(new n):this.broker.Promise.resolve();if(e.type===r.PACKET_EVENT&&null==e.target&&e.payload.groups){const r=e.payload.groups;if(r.length>0)return r.forEach((r=>{e.payload.groups=[r],this.publishBalancedEvent(e,r)})),this.broker.Promise.resolve()}else if(e.type===r.PACKET_REQUEST&&null==e.target)return this.publishBalancedRequest(e);return this.publish(e)}serialize(e){return e.payload.ver=this.broker.PROTOCOL_VERSION,e.payload.sender=this.nodeID,this.broker.serializer.serialize(e.payload,e.type)}deserialize(e,t){if(null==t)return null;const s=this.broker.serializer.deserialize(t,e);return new r.Packet(e,null,s)}};export default o;
//# sourceMappingURL=base.js.map
