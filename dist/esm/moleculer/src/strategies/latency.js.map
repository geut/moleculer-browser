{"version":3,"file":"latency.js","sources":["../../../../../src/moleculer/src/strategies/latency.js"],"sourcesContent":["/*\n * moleculer\n * Copyright (c) 2019 MoleculerJS (https://github.com/moleculerjs/moleculer)\n * MIT Licensed\n */\n\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst { random } = require(\"lodash\");\nconst BaseStrategy = require(\"./base\");\n\n/**\n * Lowest latency invocation strategy\n *\n * Since Strategy can be instantiated multiple times, therefore,\n * we need to have a \"master\" instance to send ping, and each\n * individual \"slave\" instance will update their list dynamically\n *\n * These options can be configured in broker registry options:\n *\n * const broker = new ServiceBroker({\n * \tlogger: true,\n * \tregistry: {\n * \t\tstrategy: \"LatencyStrategy\",\n * \t\tstrategyOptions: {\n * \t\t\tsampleCount: 5,\n * \t\t\tlowLatency: 10,\n * \t\t\tcollectCount: 5,\n * \t\t\tpingInterval: 10\n * \t\t}\n * \t}\n * });\n *\n * @class LatencyStrategy\n */\nclass LatencyStrategy extends BaseStrategy {\n\n\tconstructor(registry, broker, opts) {\n\t\tsuper(registry, broker, opts);\n\n\t\tthis.opts = _.defaultsDeep(opts, {\n\t\t\tsampleCount: 5,\n\t\t\tlowLatency: 10,\n\t\t\tcollectCount: 5,\n\t\t\tpingInterval: 10\n\t\t});\n\n\t\tthis.brokerStopped = false;\n\n\t\tthis.hostAvgLatency = new Map();\n\n\t\t/* hostMap contains:\n\t\t\thostname => {\n\t\t\t\thistoricLatency: [],\n\t\t\t\tnodeList: []\n\t\t\t}\n\t\t*/\n\t\tthis.hostMap = new Map();\n\n\t\t// short circuit\n\t\tif (!this.broker.transit) return;\n\n\t\tif (this.broker.localBus.listenerCount(\"$node.latencyMaster\") === 0) {\n\t\t\t// claim as master\n\t\t\tthis.broker.localBus.on(\"$node.latencyMaster\", function() {});\n\t\t\t// respond to PONG\n\t\t\tthis.broker.localBus.on(\"$node.pong\", this.processPong.bind(this));\n\t\t\t// dynamically add new node\n\t\t\tthis.broker.localBus.on(\"$node.connected\", this.addNode.bind(this));\n\t\t\t// dynamically remove node\n\t\t\tthis.broker.localBus.on(\"$node.disconnected\", this.removeHostMap.bind(this));\n\t\t\t// try to discovery all nodes on start up\n\t\t\tthis.broker.localBus.on(\"$broker.started\", this.discovery.bind(this));\n\t\t\t// clean up ourselves\n\t\t\tthis.broker.localBus.on(\"$broker.stopped\", () => this.brokerStopped = true);\n\t\t} else {\n\t\t\t// remove node if we are told by master\n\t\t\tthis.broker.localBus.on(\"$node.latencySlave.removeHost\", this.removeHostLatency.bind(this));\n\t\t}\n\n\t\tthis.broker.localBus.on(\"$node.latencySlave\", this.updateLatency.bind(this));\n\t}\n\n\t// Master\n\tdiscovery() {\n\t\treturn this.broker.transit.sendPing().then(() => {\n\t\t\tconst timer = setTimeout(() => this.pingHosts(), 1000 * this.opts.pingInterval);\n\t\t\ttimer.unref();\n\t\t});\n\t}\n\n\t// Master\n\tpingHosts() {\n\n\t\t/* istanbul ignore next */\n\t\tif (this.brokerStopped) return;\n\t\t/*\n\t\t\tSmart Ping: only ping the host, not the nodes (which may be many)\n\n\t\t\tAlthough, if that particular node on the host is overloaded,\n\t\t\tthe measurement may be skewed.\n\t\t*/\n\t\tconst hosts = Array.from(this.hostMap.values());\n\n\t\treturn this.broker.Promise.all(hosts.map(host => { // TODO: missing concurency: 5, here was bluebird Promise.map\n\t\t\t// Select a nodeID randomly\n\t\t\tconst nodeID = host.nodeList[random(0, host.nodeList.length - 1)];\n\t\t\treturn this.broker.transit.sendPing(nodeID);\n\t\t})).then(() => {\n\t\t\tconst timer = setTimeout(() => this.pingHosts(), 1000 * this.opts.pingInterval);\n\t\t\ttimer.unref();\n\t\t});\n\t}\n\n\t// Master\n\tprocessPong(payload) {\n\t\tlet node = this.registry.nodes.get(payload.nodeID);\n\n\t\t/* istanbul ignore next */\n\t\tif (!node) return;\n\n\t\tlet info = this.getHostLatency(node);\n\n\t\tif (info.historicLatency.length > (this.opts.collectCount - 1))\n\t\t\tinfo.historicLatency.shift();\n\n\t\tinfo.historicLatency.push(payload.elapsedTime);\n\n\t\tconst avgLatency = info.historicLatency.reduce((sum, latency) => sum + latency, 0) / info.historicLatency.length;\n\n\t\tthis.broker.localBus.emit(\"$node.latencySlave\", {\n\t\t\thostname: node.hostname,\n\t\t\tavgLatency: avgLatency\n\t\t});\n\t}\n\n\t// Master\n\tgetHostLatency(node) {\n\t\tlet info = this.hostMap.get(node.hostname);\n\t\tif (typeof info === \"undefined\") {\n\t\t\tinfo = {\n\t\t\t\thistoricLatency: [],\n\t\t\t\tnodeList: [ node.id ]\n\t\t\t};\n\t\t\tthis.hostMap.set(node.hostname, info);\n\t\t}\n\t\treturn info;\n\t}\n\n\t// Master\n\taddNode(payload) {\n\t\tlet node = payload.node;\n\n\t\t// each host may have multiple nodes\n\t\tlet info = this.getHostLatency(node);\n\t\tif (info.nodeList.indexOf(node.id) === -1) {\n\t\t\tinfo.nodeList.push(node.id);\n\t\t}\n\t}\n\n\t// Master\n\tremoveHostMap(payload) {\n\t\tlet node = payload.node;\n\n\t\tlet info = this.hostMap.get(node.hostname);\n\t\t// This exists to make sure that we don't get an \"undefined\",\n\t\t// \ttherefore the test coverage here is unnecessary.\n\t\t/* istanbul ignore next */\n\t\tif (typeof info === \"undefined\") return;\n\n\t\tinfo.nodeList = info.nodeList.filter(id => id !== node.id);\n\n\t\tif (info.nodeList.length == 0) {\n\t\t\t// only remove the host if the last node disconnected\n\t\t\tthis.broker.localBus.emit(\"$node.latencySlave.removeHost\", node.hostname);\n\t\t\tthis.hostMap.delete(node.hostname);\n\t\t}\n\t}\n\n\t// Master + Slave\n\tupdateLatency(payload) {\n\t\tthis.hostAvgLatency.set(payload.hostname, payload.avgLatency);\n\t}\n\n\t// Slave\n\tremoveHostLatency(hostname) {\n\t\tthis.hostAvgLatency.delete(hostname);\n\t}\n\n\t/**\n\t * Select an endpoint by network latency\n\t *\n\t * @param {Array<Endpoint>} list\n\t * @returns {Endpoint}\n\t * @memberof LatencyStrategy\n\t */\n\tselect(list) {\n\t\tlet minEp = null;\n\t\tlet minLatency = null;\n\n\t\tconst sampleCount = this.opts.sampleCount;\n\t\tconst count = sampleCount <= 0 || sampleCount > list.length ? list.length : sampleCount;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tlet ep;\n\t\t\t// Get random endpoint\n\t\t\tif (count == list.length) {\n\t\t\t\tep = list[i];\n\t\t\t} else {\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tep = list[random(0, list.length - 1)];\n\t\t\t}\n\t\t\tconst epLatency = this.hostAvgLatency.get(ep.node.hostname);\n\n\t\t\t// Check latency of endpoint\n\t\t\tif (typeof epLatency !== \"undefined\") {\n\n\t\t\t\tif (epLatency < this.opts.lowLatency)\n\t\t\t\t\treturn ep;\n\n\t\t\t\tif (!minEp || !minLatency || epLatency < minLatency) {\n\t\t\t\t\tminLatency = epLatency;\n\t\t\t\t\tminEp = ep;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the lowest latency\n\t\tif (minEp) {\n\t\t\treturn minEp;\n\t\t}\n\n\t\t// Return a random item (no latency data)\n\t\treturn list[random(0, list.length - 1)];\n\t}\n}\n\nmodule.exports = LatencyStrategy;\n"],"names":["random","_","BaseStrategy","[object Object]","registry","broker","opts","super","this","defaultsDeep","sampleCount","lowLatency","collectCount","pingInterval","brokerStopped","hostAvgLatency","Map","hostMap","transit","localBus","listenerCount","on","processPong","bind","addNode","removeHostMap","discovery","removeHostLatency","updateLatency","sendPing","then","setTimeout","pingHosts","unref","hosts","Array","from","values","Promise","all","map","host","nodeID","nodeList","length","payload","node","nodes","get","info","getHostLatency","historicLatency","shift","push","elapsedTime","avgLatency","reduce","sum","latency","emit","hostname","id","set","indexOf","filter","delete","list","minEp","minLatency","count","i","ep","epLatency"],"mappings":"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"}