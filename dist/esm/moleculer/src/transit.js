import{setTimeout as e}from"timers-browserify";import{Buffer as t}from"buffer";import s from"./packets.js";import r from"./errors.js";import n from"stream";import i from"./metrics/index.js";const{Packet:o}=s,{Transform:a}=n,{METRIC:d}=i;var c=class{constructor(e,t,s){this.broker=e,this.Promise=e.Promise,this.logger=e.getLogger("transit"),this.nodeID=e.nodeID,this.metrics=e.metrics,this.instanceID=e.instanceID,this.tx=t,this.opts=s,this.discoverer=e.registry.discoverer,this.pendingRequests=new Map,this.pendingReqStreams=new Map,this.pendingResStreams=new Map,this.stat={packets:{sent:{count:0,bytes:0},received:{count:0,bytes:0}}},this.connected=!1,this.disconnecting=!1,this.isReady=!1;const r=(e,t)=>this.messageHandler(e,t);this.publish=this.broker.wrapMethod("transitPublish",this.publish,this),this.messageHandler=this.broker.wrapMethod("transitMessageHandler",this.messageHandler,this),this.tx&&(this.tx.init(this,r,this.afterConnect.bind(this)),this.tx.send=this.broker.wrapMethod("transporterSend",this.tx.send,this.tx),this.tx.receive=this.broker.wrapMethod("transporterReceive",this.tx.receive,this.tx,{reverse:!0})),this.__connectResolve=null,this.registerMoleculerMetrics()}registerMoleculerMetrics(){this.broker.isMetricsEnabled()&&(this.metrics.register({name:d.MOLECULER_TRANSIT_READY,type:d.TYPE_GAUGE,description:"Transit is ready"}).set(0),this.metrics.register({name:d.MOLECULER_TRANSIT_CONNECTED,type:d.TYPE_GAUGE,description:"Transit is connected"}).set(0),this.metrics.register({name:d.MOLECULER_TRANSIT_PONG_TIME,type:d.TYPE_GAUGE,labelNames:["targetNodeID"],description:"Ping time"}),this.metrics.register({name:d.MOLECULER_TRANSIT_PONG_SYSTIME_DIFF,type:d.TYPE_GAUGE,labelNames:["targetNodeID"],description:"System time difference between nodes"}),this.metrics.register({name:d.MOLECULER_TRANSIT_ORPHAN_RESPONSE_TOTAL,type:d.TYPE_COUNTER,description:"Number of orphan responses"}))}afterConnect(e){return this.Promise.resolve().then((()=>e?this.discoverer.sendLocalNodeInfo():this.makeSubscriptions())).then((()=>this.discoverer.discoverAllNodes())).delay(500).then((()=>(this.connected=!0,this.metrics.set(d.MOLECULER_TRANSIT_CONNECTED,1),this.broker.broadcastLocal("$transporter.connected",{wasReconnect:!!e}),this.__connectResolve&&(this.__connectResolve(),this.__connectResolve=null),null)))}connect(){return this.logger.info("Connecting to the transporter..."),new this.Promise((t=>{this.__connectResolve=t;const s=()=>{let t=!1;const r=r=>{this.disconnecting||t||(this.logger.warn("Connection is failed.",r&&r.message||"Unknown error"),this.logger.debug(r),this.opts.disableReconnect||(t=!0,e((()=>{this.logger.info("Reconnecting..."),s()}),5e3)))};this.tx.connect(r).catch(r)};s()}))}disconnect(){return this.connected=!1,this.isReady=!1,this.disconnecting=!0,this.metrics.set(d.MOLECULER_TRANSIT_CONNECTED,0),this.broker.broadcastLocal("$transporter.disconnected",{graceFul:!0}),this.Promise.resolve().then((()=>{if(this.tx.connected)return this.discoverer.localNodeDisconnected().then((()=>this.tx.disconnect()))})).then((()=>this.disconnecting=!1))}ready(){if(this.connected)return this.isReady=!0,this.metrics.set(d.MOLECULER_TRANSIT_READY,1),this.discoverer.localNodeReady()}sendDisconnectPacket(){return this.publish(new o(s.PACKET_DISCONNECT)).catch((e=>this.logger.debug("Unable to send DISCONNECT packet.",e)))}makeSubscriptions(){return this.subscribing=this.tx.makeSubscriptions([{cmd:s.PACKET_EVENT,nodeID:this.nodeID},{cmd:s.PACKET_REQUEST,nodeID:this.nodeID},{cmd:s.PACKET_RESPONSE,nodeID:this.nodeID},{cmd:s.PACKET_DISCOVER},{cmd:s.PACKET_DISCOVER,nodeID:this.nodeID},{cmd:s.PACKET_INFO},{cmd:s.PACKET_INFO,nodeID:this.nodeID},{cmd:s.PACKET_DISCONNECT},{cmd:s.PACKET_HEARTBEAT},{cmd:s.PACKET_PING},{cmd:s.PACKET_PING,nodeID:this.nodeID},{cmd:s.PACKET_PONG,nodeID:this.nodeID}]).then((()=>{this.subscribing=null})),this.subscribing}messageHandler(e,t){try{const n=t.payload;if(!n)throw new r.MoleculerServerError("Missing response payload.",500,"MISSING_PAYLOAD");if(n.ver!==this.broker.PROTOCOL_VERSION&&!this.opts.disableVersionCheck)throw new r.ProtocolVersionMismatchError({nodeID:n.sender,actual:this.broker.PROTOCOL_VERSION,received:n.ver});if(n.sender===this.nodeID){if(e===s.PACKET_INFO&&n.instanceID!==this.instanceID)return this.broker.fatal("ServiceBroker has detected a nodeID conflict, use unique nodeIDs. ServiceBroker stopped.");if(e!==s.PACKET_EVENT&&e!==s.PACKET_REQUEST&&e!==s.PACKET_RESPONSE)return}return e===s.PACKET_REQUEST?this.requestHandler(n):(e===s.PACKET_RESPONSE?this.responseHandler(n):e===s.PACKET_EVENT?this.eventHandler(n):e===s.PACKET_DISCOVER?this.discoverer.sendLocalNodeInfo(n.sender):e===s.PACKET_INFO?this.discoverer.processRemoteNodeInfo(n.sender,n):e===s.PACKET_DISCONNECT?this.discoverer.remoteNodeDisconnected(n.sender,!1):e===s.PACKET_HEARTBEAT?this.discoverer.heartbeatReceived(n.sender,n):e===s.PACKET_PING?this.sendPong(n):e===s.PACKET_PONG&&this.processPong(n),!0)}catch(s){this.logger.error(s,e,t)}return!1}eventHandler(e){if(this.logger.debug(`Event '${e.event}' received from '${e.sender}' node`+(e.groups?` in '${e.groups.join(", ")}' group(s)`:"")+"."),!this.broker.started)return void this.logger.warn(`Incoming '${e.event}' event from '${e.sender}' node is dropped, because broker is stopped.`);const t=new this.broker.ContextFactory(this.broker);t.id=e.id,t.eventName=e.event,t.setParams(e.data,this.broker.options.contextParamsCloning),t.eventGroups=e.groups,t.eventType=e.broadcast?"broadcast":"emit",t.meta=e.meta||{},t.level=e.level,t.tracing=!!e.tracing,t.parentID=e.parentID,t.requestID=e.requestID,t.caller=e.caller,t.nodeID=e.sender,this.broker.emitLocalServices(t)}requestHandler(e){this.logger.debug(`<= Request '${e.action}' received from '${e.sender}' node.`);try{if(!this.broker.started)throw this.logger.warn(`Incoming '${e.action}' request from '${e.sender}' node is dropped because broker is stopped.`),new r.ServiceNotAvailableError({action:e.action,nodeID:this.nodeID});let t;if(void 0!==e.stream&&(t=this._handleIncomingRequestStream(e),null===t))return this.Promise.resolve();const s=this.broker._getLocalActionEndpoint(e.action),n=new this.broker.ContextFactory(this.broker);n.setEndpoint(s),n.id=e.id,n.setParams(t||e.params,this.broker.options.contextParamsCloning),n.parentID=e.parentID,n.requestID=e.requestID,n.caller=e.caller,n.meta=e.meta||{},n.level=e.level,n.tracing=e.tracing,n.nodeID=e.sender,null!=e.timeout&&(n.options.timeout=e.timeout);const i=s.action.handler(n);return i.ctx=n,i.then((t=>this.sendResponse(e.sender,e.id,n.meta,t,null))).catch((t=>this.sendResponse(e.sender,e.id,n.meta,null,t)))}catch(t){return this.sendResponse(e.sender,e.id,e.meta,null,t)}}_handleIncomingRequestStream(e){let s=this.pendingReqStreams.get(e.id),r=!1;if(!e.stream&&!s)return!1;if(s||(r=!0,this.logger.debug(`<= New stream is received from '${e.sender}'. Seq: ${e.seq}`),s=new a({objectMode:e.meta&&e.meta.$streamObjectMode,transform:function(e,t,s){return this.push(e),s()}}),s.$prevSeq=-1,s.$pool=new Map,this.pendingReqStreams.set(e.id,s)),e.seq>s.$prevSeq+1)return this.logger.info(`Put the chunk into pool (size: ${s.$pool.size}). Seq: ${e.seq}`),s.$pool.set(e.seq,e),r?s:null;if(s.$prevSeq=e.seq,s.$prevSeq>0){if(!e.stream)return e.meta&&e.meta.$streamError&&s.emit("error",this._createErrFromPayload(e.meta.$streamError,e.sender)),this.logger.debug(`<= Stream closing is received from '${e.sender}'. Seq: ${e.seq}`),s.end(),this.pendingReqStreams.delete(e.id),null;this.logger.debug(`<= Stream chunk is received from '${e.sender}'. Seq: ${e.seq}`),s.write("Buffer"===e.params.type?t.from(e.params.data):e.params)}if(s.$pool.size>0){this.logger.warn("Has stored packets. Size: "+s.$pool.size);const e=s.$prevSeq+1,t=s.$pool.get(e);t&&(s.$pool.delete(e),setImmediate((()=>this.requestHandler(t))))}return r?s:null}_createErrFromPayload(e,t){let s=r.recreateError(e);return s||(s=new Error(e.message),s.name=e.name,s.code=e.code,s.type=e.type,s.data=e.data),s.retryable=e.retryable,s.nodeID=e.nodeID||t,e.stack&&(s.stack=e.stack),s}responseHandler(e){const t=e.id,s=this.pendingRequests.get(t);if(null==s)return this.logger.debug("Orphan response is received. Maybe the request is timed out earlier. ID:",e.id,", Sender:",e.sender),void this.metrics.increment(d.MOLECULER_TRANSIT_ORPHAN_RESPONSE_TOTAL);this.logger.debug(`<= Response '${s.action.name}' is received from '${e.sender}'.`),s.ctx.nodeID=e.sender,Object.assign(s.ctx.meta||{},e.meta||{}),null!=e.stream&&this._handleIncomingResponseStream(e,s)||(this.removePendingRequest(t),e.success?s.resolve(e.data):s.reject(this._createErrFromPayload(e.error,e.sender)))}_handleIncomingResponseStream(e,s){let r=this.pendingResStreams.get(e.id);if(!r&&!e.stream)return!1;if(r||(this.logger.debug(`<= New stream is received from '${e.sender}'. Seq: ${e.seq}`),r=new a({objectMode:e.meta&&e.meta.$streamObjectMode,transform:function(e,t,s){return this.push(e),s()}}),r.$prevSeq=-1,r.$pool=new Map,this.pendingResStreams.set(e.id,r),s.resolve(r)),e.seq>r.$prevSeq+1)return this.logger.info(`Put the chunk into pool (size: ${r.$pool.size}). Seq: ${e.seq}`),r.$pool.set(e.seq,e),!0;if(r.$prevSeq=e.seq,r.$prevSeq>0){if(!e.stream)return e.success||r.emit("error",this._createErrFromPayload(e.error,e.sender)),this.logger.debug(`<= Stream closing is received from '${e.sender}'. Seq: ${e.seq}`),r.end(),this.removePendingRequest(e.id),!0;this.logger.debug(`<= Stream chunk is received from '${e.sender}'. Seq: ${e.seq}`),r.write("Buffer"===e.data.type?t.from(e.data.data):e.data)}if(r.$pool.size>0){this.logger.warn("Has stored packets. Size: "+r.$pool.size);const e=r.$prevSeq+1,t=r.$pool.get(e);t&&(r.$pool.delete(e),setImmediate((()=>this.responseHandler(t))))}return!0}request(e){return this.opts.maxQueueSize&&this.pendingRequests.size>=this.opts.maxQueueSize?this.Promise.reject(new r.QueueIsFullError({action:e.action.name,nodeID:this.nodeID,size:this.pendingRequests.size,limit:this.opts.maxQueueSize})):new this.Promise(((t,s)=>this._sendRequest(e,t,s)))}_sendRequest(e,r,n){const i=e.params&&!0===e.params.readable&&"function"==typeof e.params.on&&"function"==typeof e.params.pipe,a={action:e.action,nodeID:e.nodeID,ctx:e,resolve:r,reject:n,stream:i},d={id:e.id,action:e.action.name,params:i?null:e.params,meta:e.meta,timeout:e.options.timeout,level:e.level,tracing:e.tracing,parentID:e.parentID,requestID:e.requestID,caller:e.caller,stream:i};d.stream&&((!0===e.params.readableObjectMode||e.params._readableState&&!0===e.params._readableState.objectMode)&&(d.meta=d.meta||{},d.meta.$streamObjectMode=!0),d.seq=0);const c=new o(s.PACKET_REQUEST,e.nodeID,d),h=e.nodeID?`'${e.nodeID}'`:"someone";this.logger.debug(`=> Send '${e.action.name}' request to ${h} node.`);const l=t=>this.logger.error(`Unable to send '${e.action.name}' request to ${h} node.`,t);return this.pendingRequests.set(e.id,a),this.publish(c).then((()=>{if(i){d.meta={},(!0===e.params.readableObjectMode||e.params._readableState&&!0===e.params._readableState.objectMode)&&(d.meta.$streamObjectMode=!0);const r=e.params;r.on("data",(n=>{r.pause();const i=[];if(n instanceof t&&this.opts.maxChunkSize>0&&n.length>this.opts.maxChunkSize){let e=n.length,t=0;for(;t<e;)i.push(n.slice(t,t+=this.opts.maxChunkSize))}else i.push(n);for(const t of i){const r=Object.assign({},d);r.seq=++d.seq,r.stream=!0,r.params=t,this.logger.debug(`=> Send stream chunk to ${h} node. Seq: ${r.seq}`),this.publish(new o(s.PACKET_REQUEST,e.nodeID,r)).catch(l)}r.resume()})),r.on("end",(()=>{const t=Object.assign({},d);return t.seq=++d.seq,t.params=null,t.stream=!1,this.logger.debug(`=> Send stream closing to ${h} node. Seq: ${t.seq}`),this.publish(new o(s.PACKET_REQUEST,e.nodeID,t)).catch(l)})),r.on("error",(t=>{const r=Object.assign({},d);return r.seq=++d.seq,r.stream=!1,r.meta.$streamError=this._createPayloadErrorField(t),r.params=null,this.logger.debug(`=> Send stream error to ${h} node.`,r.meta.$streamError),this.publish(new o(s.PACKET_REQUEST,e.nodeID,r)).catch(l)}))}})).catch((e=>{l(e),n(e)}))}sendEvent(e){const t=e.eventGroups;return e.endpoint?this.logger.debug(`=> Send '${e.eventName}' event to '${e.nodeID}' node`+(t?` in '${t.join(", ")}' group(s)`:"")+"."):this.logger.debug(`=> Send '${e.eventName}' event to '${t.join(", ")}' group(s).`),this.publish(new o(s.PACKET_EVENT,e.endpoint?e.nodeID:null,{id:e.id,event:e.eventName,data:e.params,groups:t,broadcast:"broadcast"==e.eventType,meta:e.meta,level:e.level,tracing:e.tracing,parentID:e.parentID,requestID:e.requestID,caller:e.caller,needAck:e.needAck})).catch((t=>this.logger.error(`Unable to send '${e.eventName}' event to groups.`,t)))}removePendingRequest(e){this.pendingRequests.delete(e),this.pendingReqStreams.delete(e),this.pendingResStreams.delete(e)}removePendingRequestByNodeID(e){this.logger.debug(`Remove pending requests of '${e}' node.`),this.pendingRequests.forEach(((t,s)=>{t.nodeID===e&&(this.pendingRequests.delete(s),t.reject(new r.RequestRejectedError({action:t.action.name,nodeID:t.nodeID})),this.pendingReqStreams.delete(s),this.pendingResStreams.delete(s))}))}_createPayloadErrorField(e){return{name:e.name,message:e.message,nodeID:e.nodeID||this.nodeID,code:e.code,type:e.type,retryable:e.retryable,stack:e.stack,data:e.data}}sendResponse(e,r,n,i,a){const d={id:r,meta:n,success:null==a,data:i};a&&(d.error=this._createPayloadErrorField(a));const c=t=>this.logger.error(`Unable to send '${r}' response to '${e}' node.`,t);if(i&&!0===i.readable&&"function"==typeof i.on&&"function"==typeof i.pipe){d.stream=!0,(!0===i.readableObjectMode||i._readableState&&!0===i._readableState.objectMode)&&(d.meta=d.meta||{},d.meta.$streamObjectMode=!0),d.seq=0;const r=i;return r.pause(),r.on("data",(n=>{r.pause();const i=[];if(n instanceof t&&this.opts.maxChunkSize>0&&n.length>this.opts.maxChunkSize){let e=n.length,t=0;for(;t<e;)i.push(n.slice(t,t+=this.opts.maxChunkSize))}else i.push(n);for(const t of i){const r=Object.assign({},d);r.seq=++d.seq,r.stream=!0,r.data=t,this.logger.debug(`=> Send stream chunk to ${e} node. Seq: ${r.seq}`),this.publish(new o(s.PACKET_RESPONSE,e,r)).catch(c)}r.resume()})),r.on("end",(()=>{const t=Object.assign({},d);return t.stream=!1,t.seq=++d.seq,t.data=null,this.logger.debug(`=> Send stream closing to ${e} node. Seq: ${t.seq}`),this.publish(new o(s.PACKET_RESPONSE,e,t)).catch(c)})),r.on("error",(t=>{const r=Object.assign({},d);return r.stream=!1,r.seq=++d.seq,t&&(r.success=!1,r.error=this._createPayloadErrorField(t)),this.logger.debug(`=> Send stream error to ${e} node.`,r.error),this.publish(new o(s.PACKET_RESPONSE,e,r)).catch(c)})),d.data=null,this.publish(new o(s.PACKET_RESPONSE,e,d)).then((()=>{d.stream&&r.resume()})).catch(c)}return this.publish(new o(s.PACKET_RESPONSE,e,d)).catch(c)}discoverNodes(){return this.publish(new o(s.PACKET_DISCOVER)).catch((e=>this.logger.error("Unable to send DISCOVER packet.",e)))}discoverNode(e){return this.publish(new o(s.PACKET_DISCOVER,e)).catch((t=>this.logger.error(`Unable to send DISCOVER packet to '${e}' node.`,t)))}sendNodeInfo(e,t){if(!this.connected||!this.isReady)return this.Promise.resolve();return(!t&&this.broker.options.disableBalancer?this.tx.makeBalancedSubscriptions():this.Promise.resolve()).then((()=>this.publish(new o(s.PACKET_INFO,t,{services:e.services,ipList:e.ipList,hostname:e.hostname,client:e.client,config:e.config,instanceID:this.broker.instanceID,metadata:e.metadata,seq:e.seq})))).catch((e=>this.logger.error(`Unable to send INFO packet to '${t}' node.`,e)))}sendPing(e,t){return this.publish(new o(s.PACKET_PING,e,{time:Date.now(),id:t||this.broker.generateUid()})).catch((t=>this.logger.error(`Unable to send PING packet to '${e}' node.`,t)))}sendPong(e){return this.publish(new o(s.PACKET_PONG,e.sender,{time:e.time,id:e.id,arrived:Date.now()})).catch((t=>this.logger.error(`Unable to send PONG packet to '${e.sender}' node.`,t)))}processPong(e){const t=Date.now(),s=t-e.time,r=Math.round(t-e.arrived-s/2);this.broker.broadcastLocal("$node.pong",{nodeID:e.sender,elapsedTime:s,timeDiff:r,id:e.id}),this.metrics.set(d.MOLECULER_TRANSIT_PONG_TIME,s,{targetNodeID:e.sender}),this.metrics.set(d.MOLECULER_TRANSIT_PONG_SYSTIME_DIFF,r,{targetNodeID:e.sender})}sendHeartbeat(e){return this.publish(new o(s.PACKET_HEARTBEAT,null,{cpu:e.cpu})).catch((e=>this.logger.error("Unable to send HEARTBEAT packet.",e)))}subscribe(e,t){return this.tx.subscribe(e,t)}publish(e){return this.subscribing?this.subscribing.then((()=>this.tx.prepublish(e))):this.tx.prepublish(e)}};export default c;
//# sourceMappingURL=transit.js.map
