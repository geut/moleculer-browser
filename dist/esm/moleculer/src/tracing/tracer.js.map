{"version":3,"file":"tracer.js","sources":["../../../../../src/moleculer/src/tracing/tracer.js"],"sourcesContent":["/*\n * moleculer\n * Copyright (c) 2020 MoleculerJS (https://github.com/moleculerjs/moleculer)\n * MIT Licensed\n */\n\n\"use strict\";\n\nconst _ = require(\"lodash\");\nconst Exporters = require(\"./exporters\");\n//const AsyncStorage = require(\"../async-storage\");\nconst RateLimiter = require(\"./rate-limiter\");\nconst Span = require(\"./span\");\nconst { isFunction } = require(\"../utils\");\n\n/**\n * Moleculer Tracer class\n */\nclass Tracer {\n\n\t/**\n\t * Creates an instance of Tracer.\n\t *\n\t * @param {ServiceBroker} broker\n\t * @param {Object} opts\n\t * @memberof Tracer\n\t */\n\tconstructor(broker, opts) {\n\t\tthis.broker = broker;\n\t\tthis.logger = broker.getLogger(\"tracer\");\n\n\t\tif (opts === true || opts === false)\n\t\t\topts = { enabled: opts };\n\n\t\tthis.opts = _.defaultsDeep({}, opts, {\n\t\t\tenabled: true,\n\n\t\t\texporter: null,\n\n\t\t\tsampling: {\n\t\t\t\t// Constants sampling\n\t\t\t\trate: 1.0, // 0.0 - Never, 1.0 > x > 0.0 - Fix, 1.0 - Always\n\n\t\t\t\t// Ratelimiting sampling https://opencensus.io/tracing/sampling/ratelimited/\n\t\t\t\ttracesPerSecond: null, // 1: 1 trace / sec, 5: 5 traces / sec, 0.1: 1 trace / 10 secs\n\n\t\t\t\tminPriority: null\n\t\t\t},\n\n\t\t\tactions: true,\n\t\t\tevents: false,\n\n\t\t\terrorFields: [\"name\", \"message\", \"code\", \"type\", \"data\"],\n\t\t\tstackTrace: false,\n\n\t\t\tdefaultTags: null,\n\n\t\t\ttags: {\n\t\t\t\taction: null,\n\t\t\t\tevent: null,\n\t\t\t}\n\t\t});\n\n\t\tif (this.opts.stackTrace && this.opts.errorFields.indexOf(\"stack\") === -1)\n\t\t\tthis.opts.errorFields.push(\"stack\");\n\n\t\tthis.sampleCounter = 0;\n\n\t\tif (this.opts.sampling.tracesPerSecond != null && this.opts.sampling.tracesPerSecond > 0) {\n\t\t\tthis.rateLimiter = new RateLimiter({\n\t\t\t\ttracesPerSecond: this.opts.sampling.tracesPerSecond\n\t\t\t});\n\t\t}\n\n\t\t//this.scope = new AsyncStorage(this.broker);\n\t\t//this.scope.enable();\n\t\t//this._scopeEnabled = true;\n\n\t\tif (this.opts.enabled)\n\t\t\tthis.logger.info(\"Tracing: Enabled\");\n\t}\n\n\t/**\n\t * Initialize Tracer.\n\t */\n\tinit() {\n\t\tif (this.opts.enabled) {\n\n\t\t\tthis.defaultTags = isFunction(this.opts.defaultTags) ? this.opts.defaultTags.call(this, this) : this.opts.defaultTags;\n\n\t\t\t// Create Exporter instances\n\t\t\tif (this.opts.exporter) {\n\t\t\t\tconst exporters = Array.isArray(this.opts.exporter) ? this.opts.exporter : [this.opts.exporter];\n\n\t\t\t\tthis.exporter = _.compact(exporters).map(r => {\n\t\t\t\t\tconst exporter = Exporters.resolve(r);\n\t\t\t\t\texporter.init(this);\n\t\t\t\t\treturn exporter;\n\t\t\t\t});\n\n\t\t\t\tconst exporterNames = this.exporter.map(exporter => this.broker.getConstructorName(exporter));\n\t\t\t\tthis.logger.info(`Tracing exporter${exporterNames.length > 1 ? \"s\": \"\"}: ${exporterNames.join(\", \")}`);\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/**\n\t * Stop Tracer.\n\t */\n\tstop() {\n\t\tif (this.exporter) {\n\t\t\treturn this.broker.Promise.all(this.exporter.map(r => r.stop()));\n\t\t}\n\t\treturn this.broker.Promise.resolve();\n\t}\n\n\t/**\n\t * Check tracing is enabled\n\t *\n\t * @returns {boolean}\n\t * @memberof MetricRegistry\n\t */\n\tisEnabled() {\n\t\treturn this.opts.enabled;\n\t}\n\n\t/**\n\t * Disable trace hooks and clear the store - noop if scope is already stopped\n\t *\n\t * @memberof Tracer\n\t *\n\tstopAndClearScope() {\n\t\tif (this._scopeEnabled) {\n\t\t\tthis.scope.stop();\n\t\t\tthis._scopeEnabled = false;\n\t\t}\n\t}*/\n\n\t/**\n\t * Renable the trace hooks - noop if scope is already enabled\n\t *\n\t * @memberof Tracer\n\t *\n\trestartScope() {\n\t\tif (!this._scopeEnabled) {\n\t\t\tthis.scope.enable();\n\t\t\tthis._scopeEnabled = true;\n\t\t}\n\t}*/\n\n\t/**\n\t * Decide that span should be sampled.\n\t *\n\t * @param {Span} span\n\t * @returns {Boolean}\n\t * @memberof Tracer\n\t */\n\tshouldSample(span) {\n\t\tif (this.opts.sampling.minPriority != null) {\n\t\t\tif (span.priority < this.opts.sampling.minPriority)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (this.rateLimiter) {\n\t\t\treturn this.rateLimiter.check();\n\t\t}\n\n\t\tif (this.opts.sampling.rate == 0)\n\t\t\treturn false;\n\n\t\tif (this.opts.sampling.rate == 1)\n\t\t\treturn true;\n\n\t\tif (++this.sampleCounter * this.opts.sampling.rate >= 1.0) {\n\t\t\tthis.sampleCounter = 0;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Start a new Span.\n\t *\n\t * @param {String} name\n\t * @param {Object?} opts\n\t * @returns {Span}\n\t *\n\t * @memberof Tracer\n\t */\n\tstartSpan(name, opts = {}) {\n\t\tlet parentOpts = {};\n\t\tif (opts.parentSpan) {\n\t\t\tparentOpts.traceID = opts.parentSpan.traceID;\n\t\t\tparentOpts.parentID = opts.parentSpan.id;\n\t\t\tparentOpts.sampled = opts.parentSpan.sampled;\n\t\t}\n\n\t\tconst span = new Span(this, name, Object.assign({\n\t\t\ttype: \"custom\",\n\t\t\tdefaultTags: this.defaultTags\n\t\t}, parentOpts, opts, { parentSpan: undefined }));\n\n\t\tspan.start();\n\n\t\treturn span;\n\t}\n\n\t/**\n\t * Invoke Exporter method.\n\t *\n\t * @param {String} method\n\t * @param {Array<any>} args\n\t * @memberof Tracer\n\t */\n\tinvokeExporter(method, args) {\n\t\tif (this.exporter) {\n\t\t\tthis.exporter.forEach(exporter => exporter[method].apply(exporter, args));\n\t\t}\n\t}\n\n\t/**\n\t * Set the active span\n\t *\n\t * @param {Span} span\n\t * @memberof Tracer\n\t *\n\tsetCurrentSpan(span) {\n\t\tconst state = this.scope.getSessionData() || {\n\t\t\tspans: []\n\t\t};\n\n\t\tstate.spans.push(span);\n\t\tthis.scope.setSessionData(state);\n\n\t\tspan.meta.state = state;\n\t}*/\n\n\t/**\n\t * Remove the active span (because async block destroyed)\n\t *\n\t * @param {Span} span\n\t * @memberof Tracer\n\t *\n\tremoveCurrentSpan(span) {\n\t\tconst state = span.meta.state || this.scope.getSessionData();\n\t\tif (state && state.spans.length > 0) {\n\t\t\tconst idx = state.spans.indexOf(span);\n\t\t\tif (idx >= 0)\n\t\t\t\tstate.spans.splice(idx, 1);\n\t\t}\n\t}*/\n\n\t/**\n\t * Get the current active span\n\t *\n\t * @returns {Span}\n\t * @memberof Tracer\n\t *\n\tgetCurrentSpan() {\n\t\tconst state = this.scope.getSessionData();\n\t\treturn state ? state.spans[state.spans.length - 1] : null;\n\t}*/\n\n\t/**\n\t * Get the current trace ID\n\t *\n\t * @returns\n\t * @memberof Tracer\n\t */\n\tgetCurrentTraceID() {\n\t\treturn null;\n\t\t//const span = this.getCurrentSpan();\n\t\t//return span ? span.traceID : null;\n\t}\n\n\t/**\n\t * Get the active span ID (for the next span as parent ID)\n\t *\n\t * @returns\n\t * @memberof Tracer\n\t */\n\tgetActiveSpanID() {\n\t\treturn null;\n\t\t//const span = this.getCurrentSpan();\n\t\t//return span ? span.id : null;\n\t}\n\n\t/**\n\t * Called when a span started. Call exporters.\n\t *\n\t * @param {Span} span\n\t * @memberof Tracer\n\t */\n\tspanStarted(span) {\n\t\t//this.setCurrentSpan(span);\n\n\t\tif (span.sampled)\n\t\t\tthis.invokeExporter(\"spanStarted\", [span]);\n\t}\n\n\t/**\n\t * Called when a span finished. Call exporters.\n\t *\n\t * @param {Span} span\n\t * @memberof Tracer\n\t */\n\tspanFinished(span) {\n\t\t//this.removeCurrentSpan(span);\n\n\t\tif (span.sampled)\n\t\t\tthis.invokeExporter(\"spanFinished\", [span]);\n\t}\n}\n\nmodule.exports = Tracer;\n"],"names":["isFunction","require$$0","[object Object]","broker","opts","this","logger","getLogger","enabled","_","defaultsDeep","exporter","sampling","rate","tracesPerSecond","minPriority","actions","events","errorFields","stackTrace","defaultTags","tags","action","event","indexOf","push","sampleCounter","rateLimiter","RateLimiter","info","call","exporters","Array","isArray","compact","map","r","Exporters","resolve","init","exporterNames","getConstructorName","length","join","Promise","all","stop","span","priority","check","name","parentOpts","parentSpan","traceID","parentID","id","sampled","Span","Object","assign","type","undefined","start","method","args","forEach","apply","invokeExporter"],"mappings":"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"}