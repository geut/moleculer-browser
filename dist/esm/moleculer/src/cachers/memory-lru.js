import{setInterval as e}from"timers-browserify";import t from"lodash";import s from"../utils.js";import r from"../metrics/index.js";import i from"lru-cache";import o from"./base.js";import c from"../lock.js";const{METRIC:h}=r;var l=class extends o{constructor(s){super(s),this.cache=new i({max:this.opts.max,maxAge:this.opts.ttl?1e3*this.opts.ttl:null,updateAgeOnGet:!!this.opts.ttl}),this._lock=new c,this.timer=e((()=>{this.checkTTL()}),3e4),this.timer.unref(),this.clone=!0===this.opts.clone?t.cloneDeep:this.opts.clone}init(e){super.init(e),e.localBus.on("$transporter.connected",(()=>this.clean())),this.opts.lock&&!1!==this.opts.lock.enabled&&this.opts.lock.staleTime&&this.logger.warn("setting lock.staleTime with MemoryLRUCacher is not supported.")}close(){return clearInterval(this.timer),Promise.resolve()}get(e){this.logger.debug("GET "+e),this.metrics.increment(h.MOLECULER_CACHER_GET_TOTAL);const t=this.metrics.timer(h.MOLECULER_CACHER_GET_TIME);if(this.cache.has(e)){this.logger.debug("FOUND "+e),this.metrics.increment(h.MOLECULER_CACHER_FOUND_TOTAL);let s=this.cache.get(e);const r=this.clone?this.clone(s):s;return t(),this.broker.Promise.resolve(r)}return t(),this.broker.Promise.resolve(null)}set(e,t,s){this.metrics.increment(h.MOLECULER_CACHER_SET_TOTAL);const r=this.metrics.timer(h.MOLECULER_CACHER_SET_TIME);return null==s&&(s=this.opts.ttl),this.cache.set(e,t,s?1e3*s:null),r(),this.logger.debug("SET "+e),this.broker.Promise.resolve(t)}del(e){this.metrics.increment(h.MOLECULER_CACHER_DEL_TOTAL);const t=this.metrics.timer(h.MOLECULER_CACHER_DEL_TIME);return(e=Array.isArray(e)?e:[e]).forEach((e=>{this.cache.del(e),this.logger.debug("REMOVE "+e)})),t(),this.broker.Promise.resolve()}clean(e="**"){this.metrics.increment(h.MOLECULER_CACHER_CLEAN_TOTAL);const t=this.metrics.timer(h.MOLECULER_CACHER_CLEAN_TIME),r=Array.isArray(e)?e:[e];return this.logger.debug("CLEAN "+r.join(", ")),this.cache.keys().forEach((e=>{r.some((t=>s.match(e,t)))&&(this.logger.debug("REMOVE "+e),this.cache.del(e))})),t(),this.broker.Promise.resolve()}getWithTTL(e){return this.get(e).then((e=>({data:e,ttl:null})))}lock(e,t){return this._lock.acquire(e,t).then((()=>()=>this._lock.release(e)))}tryLock(e,t){return this._lock.isLocked(e)?this.broker.Promise.reject(new Error("Locked.")):this._lock.acquire(e,t).then((()=>()=>this._lock.release(e)))}checkTTL(){this.cache.prune()}};export default l;
//# sourceMappingURL=memory-lru.js.map
