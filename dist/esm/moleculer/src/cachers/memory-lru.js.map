{"version":3,"file":"memory-lru.js","sources":["../../../../../src/moleculer/src/cachers/memory-lru.js"],"sourcesContent":["/*\n * moleculer\n * Copyright (c) 2018 MoleculerJS (https://github.com/moleculerjs/moleculer)\n * MIT Licensed\n */\n\n\"use strict\";\n\nconst _ \t\t\t= require(\"lodash\");\nconst utils\t\t\t= require(\"../utils\");\nconst BaseCacher  \t= require(\"./base\");\nconst LRU \t\t\t= require(\"lru-cache\");\nconst { METRIC }\t= require(\"../metrics\");\n\nconst Lock = require(\"../lock\");\n/**\n * Cacher factory for memory cache\n *\n * @class MemoryLRUCacher\n */\nclass MemoryLRUCacher extends BaseCacher {\n\n\t/**\n\t * Creates an instance of MemoryLRUCacher.\n\t *\n\t * @param {object} opts\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\tconstructor(opts) {\n\t\tsuper(opts);\n\n\t\t// Cache container\n\t\tthis.cache = new LRU({\n\t\t\tmax: this.opts.max,\n\t\t\tmaxAge: this.opts.ttl ? this.opts.ttl * 1000 : null,\n\t\t\tupdateAgeOnGet: !!this.opts.ttl\n\t\t});\n\t\t// Async lock\n\t\tthis._lock = new Lock();\n\t\t// Start TTL timer\n\t\tthis.timer = setInterval(() => {\n\t\t\t/* istanbul ignore next */\n\t\t\tthis.checkTTL();\n\t\t}, 30 * 1000);\n\t\tthis.timer.unref();\n\n\t\t// Set cloning\n\t\tthis.clone = this.opts.clone === true ? _.cloneDeep : this.opts.clone;\n\t}\n\n\t/**\n\t * Initialize cacher\n\t *\n\t * @param {any} broker\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\tinit(broker) {\n\t\tsuper.init(broker);\n\n\t\tbroker.localBus.on(\"$transporter.connected\", () => {\n\t\t\t// Clear all entries after transporter connected. Maybe we missed some \"cache.clear\" events.\n\t\t\treturn this.clean();\n\t\t});\n\t\tif(this.opts.lock && this.opts.lock.enabled !== false && this.opts.lock.staleTime){\n\t\t\t/* istanbul ignore next */\n\t\t\tthis.logger.warn(\"setting lock.staleTime with MemoryLRUCacher is not supported.\");\n\t\t}\n\t}\n\n\t/**\n\t * Close cacher\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\tclose() {\n\t\tclearInterval(this.timer);\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Get data from cache by key\n\t *\n\t * @param {any} key\n\t * @returns {Promise}\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\tget(key) {\n\t\tthis.logger.debug(`GET ${key}`);\n\t\tthis.metrics.increment(METRIC.MOLECULER_CACHER_GET_TOTAL);\n\t\tconst timeEnd = this.metrics.timer(METRIC.MOLECULER_CACHER_GET_TIME);\n\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.logger.debug(`FOUND ${key}`);\n\t\t\tthis.metrics.increment(METRIC.MOLECULER_CACHER_FOUND_TOTAL);\n\n\t\t\tlet item = this.cache.get(key);\n\t\t\tconst res = this.clone ? this.clone(item) : item;\n\t\t\ttimeEnd();\n\n\t\t\treturn this.broker.Promise.resolve(res);\n\t\t} else {\n\t\t\ttimeEnd();\n\t\t}\n\t\treturn this.broker.Promise.resolve(null);\n\t}\n\n\t/**\n\t * Save data to cache by key\n\t *\n\t * @param {String} key\n\t * @param {any} data JSON object\n\t * @param {Number} ttl Optional Time-to-Live\n\t * @returns {Promise}\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\tset(key, data, ttl) {\n\t\tthis.metrics.increment(METRIC.MOLECULER_CACHER_SET_TOTAL);\n\t\tconst timeEnd = this.metrics.timer(METRIC.MOLECULER_CACHER_SET_TIME);\n\n\t\tif (ttl == null)\n\t\t\tttl = this.opts.ttl;\n\n\t\tthis.cache.set(key, data, ttl ? ttl * 1000 : null);\n\n\t\ttimeEnd();\n\t\tthis.logger.debug(`SET ${key}`);\n\n\t\treturn this.broker.Promise.resolve(data);\n\t}\n\n\t/**\n\t * Delete a key from cache\n\t *\n\t * @param {string|Array<string>} key\n\t * @returns {Promise}\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\tdel(keys) {\n\t\tthis.metrics.increment(METRIC.MOLECULER_CACHER_DEL_TOTAL);\n\t\tconst timeEnd = this.metrics.timer(METRIC.MOLECULER_CACHER_DEL_TIME);\n\n\t\tkeys = Array.isArray(keys) ? keys : [keys];\n\t\tkeys.forEach(key => {\n\t\t\tthis.cache.del(key);\n\t\t\tthis.logger.debug(`REMOVE ${key}`);\n\t\t});\n\t\ttimeEnd();\n\n\t\treturn this.broker.Promise.resolve();\n\t}\n\n\t/**\n\t * Clean cache. Remove every key by match\n\t * @param {string|Array<string>} match string. Default is \"**\"\n\t * @returns {Promise}\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\tclean(match = \"**\") {\n\t\tthis.metrics.increment(METRIC.MOLECULER_CACHER_CLEAN_TOTAL);\n\t\tconst timeEnd = this.metrics.timer(METRIC.MOLECULER_CACHER_CLEAN_TIME);\n\n\t\tconst matches = Array.isArray(match) ? match : [match];\n\t\tthis.logger.debug(`CLEAN ${matches.join(\", \")}`);\n\n\t\tthis.cache.keys().forEach(key => {\n\t\t\tif (matches.some(match => utils.match(key, match))) {\n\t\t\t\tthis.logger.debug(`REMOVE ${key}`);\n\t\t\t\tthis.cache.del(key);\n\t\t\t}\n\t\t});\n\t\ttimeEnd();\n\n\t\treturn this.broker.Promise.resolve();\n\t}\n\t/**\n\t * Get data and ttl from cache by key.\n\t *\n\t * @param {string|Array<string>} key\n\t * @returns {Promise}\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\tgetWithTTL(key){\n\t\t// There are no way to get the ttl of LRU cache :(\n\t\treturn this.get(key).then(data=>{\n\t\t\treturn { data, ttl: null };\n\t\t});\n\t}\n\n\t/**\n\t * Acquire a lock\n\t *\n\t * @param {string|Array<string>} key\n\t * @param {Number} ttl Optional Time-to-Live\n\t * @returns {Promise}\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\n\tlock(key, ttl) {\n\t\treturn this._lock.acquire(key, ttl).then(()=> {\n\t\t\treturn ()=>this._lock.release(key);\n\t\t});\n\t}\n\n\t/**\n\t * Try to acquire a lock\n\t *\n\t * @param {string|Array<string>} key\n\t * @param {Number} ttl Optional Time-to-Live\n\t * @returns {Promise}\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\ttryLock(key, ttl) {\n\t\tif(this._lock.isLocked(key)){\n\t\t\treturn this.broker.Promise.reject(new Error(\"Locked.\"));\n\t\t}\n\t\treturn this._lock.acquire(key, ttl).then(()=> {\n\t\t\treturn ()=>this._lock.release(key);\n\t\t});\n\t}\n\n\n\t/**\n\t * Check & remove the expired cache items\n\t *\n\t * @memberof MemoryLRUCacher\n\t */\n\tcheckTTL() {\n\t\tthis.cache.prune();\n\t}\n}\n\nmodule.exports = MemoryLRUCacher;\n"],"names":["METRIC","require$$0","BaseCacher","[object Object]","opts","super","this","cache","LRU","max","maxAge","ttl","updateAgeOnGet","_lock","Lock","timer","setInterval","checkTTL","unref","clone","_","cloneDeep","broker","init","localBus","on","clean","lock","enabled","staleTime","logger","warn","clearInterval","Promise","resolve","key","debug","metrics","increment","MOLECULER_CACHER_GET_TOTAL","timeEnd","MOLECULER_CACHER_GET_TIME","has","MOLECULER_CACHER_FOUND_TOTAL","item","get","res","data","MOLECULER_CACHER_SET_TOTAL","MOLECULER_CACHER_SET_TIME","set","keys","MOLECULER_CACHER_DEL_TOTAL","MOLECULER_CACHER_DEL_TIME","Array","isArray","forEach","del","match","MOLECULER_CACHER_CLEAN_TOTAL","MOLECULER_CACHER_CLEAN_TIME","matches","join","some","utils","then","acquire","release","isLocked","reject","Error","prune"],"mappings":"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"}