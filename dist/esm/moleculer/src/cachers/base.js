import e from"lodash";import t from"../utils.js";import r from"../metrics/index.js";import s from"crypto";const{METRIC:i}=r,{isObject:n,isFunction:h}=t;var a=class{constructor(t){this.opts=e.defaultsDeep(t,{ttl:null,keygen:null,maxParamsLength:null})}init(e){this.broker=e,this.metrics=e.metrics,this.broker&&(this.logger=e.getLogger("cacher"),this.opts.prefix?this.prefix=this.opts.prefix+"-":(this.prefix="MOL-",this.broker.namespace&&(this.prefix+=this.broker.namespace+"-")),this.registerMoleculerMetrics())}registerMoleculerMetrics(){this.metrics.register({name:i.MOLECULER_CACHER_GET_TOTAL,type:i.TYPE_COUNTER,rate:!0}),this.metrics.register({name:i.MOLECULER_CACHER_GET_TIME,type:i.TYPE_HISTOGRAM,quantiles:!0,unit:i.UNIT_MILLISECONDS}),this.metrics.register({name:i.MOLECULER_CACHER_FOUND_TOTAL,type:i.TYPE_COUNTER,rate:!0}),this.metrics.register({name:i.MOLECULER_CACHER_SET_TOTAL,type:i.TYPE_COUNTER,rate:!0}),this.metrics.register({name:i.MOLECULER_CACHER_SET_TIME,type:i.TYPE_HISTOGRAM,quantiles:!0,unit:i.UNIT_MILLISECONDS}),this.metrics.register({name:i.MOLECULER_CACHER_DEL_TOTAL,type:i.TYPE_COUNTER,rate:!0}),this.metrics.register({name:i.MOLECULER_CACHER_DEL_TIME,type:i.TYPE_HISTOGRAM,quantiles:!0,unit:i.UNIT_MILLISECONDS}),this.metrics.register({name:i.MOLECULER_CACHER_CLEAN_TOTAL,type:i.TYPE_COUNTER,rate:!0}),this.metrics.register({name:i.MOLECULER_CACHER_CLEAN_TIME,type:i.TYPE_HISTOGRAM,quantiles:!0,unit:i.UNIT_MILLISECONDS}),this.metrics.register({name:i.MOLECULER_CACHER_EXPIRED_TOTAL,type:i.TYPE_COUNTER,rate:!0})}close(){return Promise.resolve()}get(){throw new Error("Not implemented method!")}getWithTTL(){throw new Error("Not implemented method!")}set(){throw new Error("Not implemented method!")}del(){throw new Error("Not implemented method!")}clean(){throw new Error("Not implemented method!")}getParamMetaValue(t,r,s){return t.startsWith("#")&&null!=s?e.get(s,t.slice(1)):null!=r?e.get(r,t):void 0}defaultKeygen(e,t,r,s){if(t||r){const i=e+":";if(!s)return i+this._hashedKey(this._generateKeyFromObject(t));if(1==s.length){const e=this.getParamMetaValue(s[0],t,r);return i+this._hashedKey(n(e)?this._hashedKey(this._generateKeyFromObject(e)):e)}if(s.length>0)return i+this._hashedKey(s.reduce(((e,s,i)=>{const h=this.getParamMetaValue(s,t,r);return e+(i?"|":"")+(n(h)||Array.isArray(h)?this._hashedKey(this._generateKeyFromObject(h)):h)}),""))}return e}_hashedKey(e){const t=this.opts.maxParamsLength;if(!t||t<44||e.length<=t)return e;const r=t-44,i=s.createHash("sha256").update(e).digest("base64");return r<1?i:e.substring(0,r)+i}_generateKeyFromObject(e){return Array.isArray(e)?e.map((e=>this._generateKeyFromObject(e))).join("|"):n(e)?Object.keys(e).map((t=>[t,this._generateKeyFromObject(e[t])].join("|"))).join("|"):null!=e?e.toString():"null"}getCacheKey(e,t,r,s){return h(this.opts.keygen)?this.opts.keygen.call(this,e,t,r,s):this.defaultKeygen(e,t,r,s)}middleware(){return(t,r)=>{const s=e.defaultsDeep({},n(r.cache)?r.cache:{enabled:!!r.cache});if(s.lock=e.defaultsDeep({},n(s.lock)?s.lock:{enabled:!!s.lock}),!1!==s.enabled){const e=h(s.enabled);return function(i){if(e&&!s.enabled.call(i.service,i))return t(i);if(!1===i.meta.$cache)return t(i);const n=this.getCacheKey(r.name,i.params,i.meta,s.keys);if(!1!==s.lock.enabled){let e;return e=s.lock.staleTime&&this.getWithTTL?this.getWithTTL(n).then((({data:e,ttl:r})=>(null!=e&&s.lock.staleTime&&r&&r<s.lock.staleTime&&this.tryLock(n,s.lock.ttl).then((e=>t(i).then((t=>this.set(n,t,s.ttl).then((()=>e())))).catch((()=>this.del(n).then((()=>e())))))).catch((()=>{})),e))):this.get(n),e.then((e=>null!=e?(i.cachedResult=!0,e):this.lock(n,s.lock.ttl).then((e=>this.get(n).then((r=>null!=r?(i.cachedResult=!0,e().then((()=>r))):t(i).then((t=>(this.set(n,t,s.ttl).then((()=>e())),t))).catch((t=>e().then((()=>Promise.reject(t)))))))))))}return this.get(n).then((e=>null!=e?(i.cachedResult=!0,e):t(i).then((e=>(this.set(n,e,s.ttl),e)))))}.bind(this)}return t}}};export default a;
//# sourceMappingURL=base.js.map
