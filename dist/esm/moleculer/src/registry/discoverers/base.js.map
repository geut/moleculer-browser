{"version":3,"file":"base.js","sources":["../../../../../../src/moleculer/src/registry/discoverers/base.js"],"sourcesContent":["/*\n * moleculer\n * Copyright (c) 2020 MoleculerJS (https://github.com/moleculerjs/moleculer)\n * MIT Licensed\n */\n\n\"use strict\";\n\nconst _ = require(\"lodash\");\n\n/**\n * Abstract Discoverer class\n *\n * @class BaseDiscoverer\n */\nclass BaseDiscoverer {\n\n\t/**\n\t * Creates an instance of Discoverer.\n\t *\n\t * @memberof BaseDiscoverer\n\t */\n\tconstructor(opts) {\n\t\tthis.Promise = Promise; // while `init` is not called\n\n\t\tthis.opts = _.defaultsDeep({}, opts, {\n\t\t\theartbeatInterval: null,\n\t\t\theartbeatTimeout: null,\n\n\t\t\tdisableHeartbeatChecks: false,\n\t\t\tdisableOfflineNodeRemoving: false,\n\t\t\tcleanOfflineNodesTimeout: 10 * 60, // 10 minutes\n\t\t});\n\n\t\t// Timer variables\n\t\tthis.heartbeatTimer = null;\n\t\tthis.checkNodesTimer = null;\n\t\tthis.offlineTimer = null;\n\n\t\t// Pointer for the local `Node` instance\n\t\tthis.localNode = null;\n\t}\n\n\t/**\n\t * Initialize Discoverer\n\t *\n\t * @param {ServiceRegistry} registry\n\t */\n\tinit(registry) {\n\t\tthis.registry = registry;\n\t\tthis.broker = registry.broker;\n\t\tthis.Promise = this.broker.Promise;\n\n\t\tif (this.broker) {\n\t\t\tthis.logger = this.broker.getLogger(\"Discovery\");\n\t\t\tthis.transit = this.broker.transit;\n\n\t\t\t// Get HB time settings from broker options. Backward compatibility\n\t\t\tif (this.opts.heartbeatInterval == null)\n\t\t\t\tthis.opts.heartbeatInterval = this.broker.options.heartbeatInterval;\n\t\t\tif (this.opts.heartbeatTimeout == null)\n\t\t\t\tthis.opts.heartbeatTimeout = this.broker.options.heartbeatTimeout;\n\t\t}\n\n\t\tif (this.transit) {\n\t\t\tthis.broker.localBus.on(\"$transporter.connected\", () => this.startHeartbeatTimers());\n\t\t\tthis.broker.localBus.on(\"$transporter.disconnected\", () => this.stopHeartbeatTimers());\n\t\t}\n\n\t\tthis.localNode = this.registry.nodes.localNode;\n\n\t\tthis.registerMoleculerMetrics();\n\t}\n\n\t/**\n\t * Stop discoverer clients.\n\t */\n\tstop() {\n\t\tthis.stopHeartbeatTimers();\n\t\treturn this.Promise.resolve();\n\t}\n\n\t/**\n\t * Register Moleculer Transit Core metrics.\n\t */\n\tregisterMoleculerMetrics() {\n\t\t// Not implemented\n\t}\n\n\t/**\n\t * Start heartbeat timers\n\t */\n\tstartHeartbeatTimers() {\n\t\tthis.stopHeartbeatTimers();\n\n\t\tif (this.opts.heartbeatInterval > 0) {\n\t\t\t// HB timer\n\t\t\tconst time = this.opts.heartbeatInterval * 1000 + (Math.round(Math.random() * 1000) - 500); // random +/- 500ms\n\t\t\tthis.heartbeatTimer = setInterval(() => this.beat(), time);\n\t\t\tthis.heartbeatTimer.unref();\n\n\t\t\t// Check expired heartbeats of remote nodes timer\n\t\t\tthis.checkNodesTimer = setInterval(() => this.checkRemoteNodes(), this.opts.heartbeatTimeout * 1000);\n\t\t\tthis.checkNodesTimer.unref();\n\n\t\t\t// Clean offline nodes timer\n\t\t\tthis.offlineTimer = setInterval(() => this.checkOfflineNodes(), 60 * 1000); // 1 min\n\t\t\tthis.offlineTimer.unref();\n\t\t}\n\t}\n\n\t/**\n\t * Stop heartbeat timers\n\t */\n\tstopHeartbeatTimers() {\n\t\tif (this.heartbeatTimer) {\n\t\t\tclearInterval(this.heartbeatTimer);\n\t\t\tthis.heartbeatTimer = null;\n\t\t}\n\n\t\tif (this.checkNodesTimer) {\n\t\t\tclearInterval(this.checkNodesTimer);\n\t\t\tthis.checkNodesTimer = null;\n\t\t}\n\n\t\tif (this.offlineTimer) {\n\t\t\tclearInterval(this.offlineTimer);\n\t\t\tthis.offlineTimer = null;\n\t\t}\n\t}\n\n\t/**\n\t * Disable built-in Heartbeat logic. Used by TCP transporter\n\t */\n\tdisableHeartbeat() {\n\t\tthis.opts.heartbeatInterval = 0;\n\t\tthis.stopHeartbeatTimers();\n\t}\n\n\t/**\n\t * Heartbeat method.\n\t */\n\tbeat() {\n\t\t// Update the local CPU usage before sending heartbeat.\n\t\treturn this.localNode.updateLocalInfo(this.broker.getCpuUsage)\n\t\t\t.then(() => this.sendHeartbeat());\n\t}\n\n\t/**\n\t * Check all registered remote nodes are available.\n\t */\n\tcheckRemoteNodes() {\n\t\tif (this.disableHeartbeatChecks) return;\n\n\t\tconst now = Math.round(process.uptime());\n\t\tthis.registry.nodes.toArray().forEach(node => {\n\t\t\tif (node.local || !node.available) return;\n\t\t\tif (!node.lastHeartbeatTime) {\n\t\t\t\t// Még nem jött be az első heartbeat.\n\t\t\t\tnode.lastHeartbeatTime = now;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (now - node.lastHeartbeatTime > this.broker.options.heartbeatTimeout) {\n\t\t\t\tthis.logger.warn(`Heartbeat is not received from '${node.id}' node.`);\n\t\t\t\tthis.registry.nodes.disconnected(node.id, true);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Check offline nodes. Remove which is older than 10 minutes.\n\t */\n\tcheckOfflineNodes() {\n\t\tif (this.disableOfflineNodeRemoving || !this.opts.cleanOfflineNodesTimeout) return;\n\n\t\tconst now = Math.round(process.uptime());\n\t\tthis.registry.nodes.toArray().forEach(node => {\n\t\t\tif (node.local || node.available) return;\n\t\t\tif (!node.lastHeartbeatTime) {\n\t\t\t\t// Még nem jött be az első heartbeat.\n\t\t\t\tnode.lastHeartbeatTime = now;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (now - node.lastHeartbeatTime > this.opts.cleanOfflineNodesTimeout) {\n\t\t\t\tthis.logger.warn(`Removing offline '${node.id}' node from registry because it hasn't submitted heartbeat signal for 10 minutes.`);\n\t\t\t\tthis.registry.nodes.delete(node.id);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Heartbeat received from a remote node.\n\t *\n\t * @param {String} nodeID\n\t * @param {Object} payload\n\t */\n\theartbeatReceived(nodeID, payload) {\n\t\tconst node = this.registry.nodes.get(nodeID);\n\t\tif (node) {\n\t\t\tif (!node.available) {\n\t\t\t\t// Reconnected node. Request a fresh INFO\n\t\t\t\tthis.discoverNode(nodeID);\n\t\t\t} else {\n\t\t\t\tif (payload.seq != null && node.seq !== payload.seq) {\n\t\t\t\t\t// Some services changed on the remote node. Request a new INFO\n\t\t\t\t\tthis.discoverNode(nodeID);\n\t\t\t\t} else if (payload.instanceID != null && !node.instanceID.startsWith(payload.instanceID)) {\n\t\t\t\t\t// The node has been restarted. Request a new INFO\n\t\t\t\t\tthis.discoverNode(nodeID);\n\t\t\t\t} else {\n\t\t\t\t\tnode.heartbeat(payload);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Unknow node. Request an INFO\n\t\t\tthis.discoverNode(nodeID);\n\t\t}\n\t}\n\n\t/**\n\t * Received an INFO from a remote node.\n\t *\n\t * @param {String} nodeID\n\t * @param {Object} payload\n\t */\n\tprocessRemoteNodeInfo(nodeID, payload) {\n\t\treturn this.broker.registry.processNodeInfo(payload);\n\t}\n\n\t/**\n\t * Sending a local heartbeat to remote nodes.\n\t */\n\tsendHeartbeat() {\n\t\tif (!this.transit) return this.Promise.resolve();\n\t\treturn this.transit.sendHeartbeat(this.localNode);\n\t}\n\n\t/**\n\t * Discover a new or old node by nodeID\n\t *\n\t * @param {String} nodeID\n\t */\n\tdiscoverNode() {\n\t\t/* istanbul ignore next */\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\n\t/**\n\t * Discover all nodes (after connected)\n\t */\n\tdiscoverAllNodes() {\n\t\t/* istanbul ignore next */\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\n\t/**\n\t * Called when the local node is ready (transporter connected)\n\t */\n\tlocalNodeReady() {\n\t\t// Local node has started all local services. We send a new INFO packet\n\t\t// which contains the local services because we are ready to accept incoming requests.\n\t\treturn this.sendLocalNodeInfo();\n\t}\n\n\t/**\n\t * Local service registry has been changed. We should notify remote nodes.\n\t *\n\t * @param {String} nodeID\n\t */\n\tsendLocalNodeInfo() {\n\t\t/* istanbul ignore next */\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\n\t/**\n\t * Called when the local node disconnected.\n\t * You can clean it from the remote registry.\n\t */\n\tlocalNodeDisconnected() {\n\t\tif (!this.transit) return this.Promise.resolve();\n\t\treturn this.transit.sendDisconnectPacket();\n\t}\n\n\t/**\n\t * Called when a remote node disconnected (received DISCONNECT packet)\n\t * You can clean it from local registry.\n\t *\n\t * @param {String} nodeID\n\t * @param {Boolean} isUnexpected\n\t */\n\tremoteNodeDisconnected(nodeID, isUnexpected) {\n\t\treturn this.registry.nodes.disconnected(nodeID, isUnexpected);\n\t}\n\n}\n\nmodule.exports = BaseDiscoverer;\n"],"names":["[object Object]","opts","this","Promise","_","defaultsDeep","heartbeatInterval","heartbeatTimeout","disableHeartbeatChecks","disableOfflineNodeRemoving","cleanOfflineNodesTimeout","heartbeatTimer","checkNodesTimer","offlineTimer","localNode","registry","broker","logger","getLogger","transit","options","localBus","on","startHeartbeatTimers","stopHeartbeatTimers","nodes","registerMoleculerMetrics","resolve","time","Math","round","random","setInterval","beat","unref","checkRemoteNodes","checkOfflineNodes","clearInterval","updateLocalInfo","getCpuUsage","then","sendHeartbeat","now","process","uptime","toArray","forEach","node","local","available","lastHeartbeatTime","warn","id","disconnected","delete","nodeID","payload","get","seq","discoverNode","instanceID","startsWith","heartbeat","processNodeInfo","Error","sendLocalNodeInfo","sendDisconnectPacket","isUnexpected"],"mappings":"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"}