import e from"lodash";import t from"../utils.js";import n from"../strategies/index.js";import r from"./endpoint-list.js";import s from"./endpoint-event.js";var o=class{constructor(e,t,n){this.registry=e,this.broker=t,this.logger=e.logger,this.StrategyFactory=n,this.events=[],this.EndpointFactory=s}add(e,t,s){const o=s.name,a=s.group||t.name;let i=this.get(o,a);if(!i){const e=s.strategy&&n.resolve(s.strategy)||this.StrategyFactory,t=s.strategyOptions?s.strategyOptions:this.registry.opts.strategyOptions;i=new r(this.registry,this.broker,o,a,this.EndpointFactory,e,t),this.events.push(i)}return i.add(e,t,s),i}get(e,t){return this.events.find((n=>n.name==e&&n.group==t))}getBalancedEndpoints(e,n){const r=[];return this.events.forEach((s=>{if(t.match(e,s.name)&&(null==n||0==n.length||-1!=n.indexOf(s.group))){const e=s.next();e&&e.isAvailable&&r.push([e,s.group])}})),r}getGroups(n){return e.uniq(this.events.filter((e=>t.match(n,e.name))).map((e=>e.group)))}getAllEndpoints(n,r){const s=[];return this.events.forEach((e=>{t.match(n,e.name)&&(null!=r&&0!=r.length&&-1===r.indexOf(e.group)||e.endpoints.forEach((e=>{e.isAvailable&&s.push(e)})))})),e.uniqBy(s,"id")}emitLocalServices(e){const n=-1!==["broadcast","broadcastLocal"].indexOf(e.eventType),r=e.nodeID,s=[];return this.events.forEach((o=>{if(t.match(e.eventName,o.name)&&(null==e.eventGroups||0==e.eventGroups.length||-1!==e.eventGroups.indexOf(o.group)))if(n)o.endpoints.forEach((t=>{if(t.local&&t.event.handler){const n=e.copy(t);n.nodeID=r,s.push(this.callEventHandler(n))}}));else{const t=o.nextLocal();if(t&&t.event.handler){const n=e.copy(t);n.nodeID=r,s.push(this.callEventHandler(n))}}})),this.broker.Promise.all(s)}callEventHandler(e){return e.endpoint.event.handler(e)}removeByService(e){this.events.forEach((t=>{t.removeByService(e)}))}remove(e,t){this.events.forEach((n=>{n.name==e&&n.removeByNodeID(t)}))}list({onlyLocal:t=!1,onlyAvailable:n=!1,skipInternal:r=!1,withEndpoints:s=!1}){let o=[];return this.events.forEach((a=>{if(r&&/^\$/.test(a.name))return;if(t&&!a.hasLocal())return;if(n&&!a.hasAvailable())return;let i={name:a.name,group:a.group,count:a.count(),hasLocal:a.hasLocal(),available:a.hasAvailable()};if(i.count>0){const t=a.endpoints[0];t&&(i.event=e.omit(t.event,["handler","remoteHandler","service"]))}s&&i.count>0&&(i.endpoints=a.endpoints.map((e=>({nodeID:e.node.id,state:e.state,available:e.node.available})))),o.push(i)})),o}};export default o;
//# sourceMappingURL=event-catalog.js.map
